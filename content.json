[{"title":"ES6","slug":"ES6","date":"2018-09-17T11:02:23.000Z","updated":"2018-09-20T09:00:37.935Z","comments":true,"path":"2018/09/17/ES6/","link":"","permalink":"http://yoursite.com/2018/09/17/ES6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"react开发打包环境的搭建","slug":"reactProductEnvironment","date":"2018-03-18T14:30:07.000Z","updated":"2018-09-20T08:56:55.371Z","comments":true,"path":"2018/03/18/reactProductEnvironment/","link":"","permalink":"http://yoursite.com/2018/03/18/reactProductEnvironment/","excerpt":"","text":"1.git的安装和配置 git安装(想必都会，只总结mac系统遇到的问题) 官网下载git的.dmg安装包，双击打开，双击.pkg的安装包，😯，报错了…打不开身份不明开发者。这是由于mac安全限制外部下载的软件。 解决方案：打开系统偏好设置&gt;安全与隐私&gt;通用：提示已阻止打开“git-…pkg”,因为来自身份不明的开发者。倔强地选择仍要打开。 接着傻瓜式下一步…ok。 检测是不是安装成功了(成功输出git的版本号) 1$ git --version 配置.gitconfig(它是一个用户目录下的隐藏文件，终端ls看不见隐藏文件，ls -all可以看见) 1$ vim ~/.gitconfig 进来之后，用小写字母i进入编辑模式，user不配置首次提交的时候也会让你输入，这里的email是注册git的时候使用的邮箱。alias是git命令简写，我只配了一些常用的。 123456789101112[user] name=Grace email=***@163.com[alias] co=checkout ci=commit st=status pl=pull ps=push dt=difftool ca=commit -am b=branch 写好之后按ESC推出编辑模式，输入:wq+回车保存并退出.gitconfig的编辑模式，我们还可以查看刚才的配置信息。 1$ cat ~/.gitconfig 2.项目的建立 获取ssh密钥邮箱是刚才配置的那个，执行完这条命令之后，一直回车到执行完 1$ ssh-keygen -t rsa -C '***@163.com' 此时会在用户目录下生成一个.ssh的文件夹，cd到这个文件夹,ls-all查看所有文件，那个id_rsa.pub就是存放公钥的文件 1$ cat id_rsa.pub 查看公钥内容，复制下来。 打开gitee.com，码云在国内，速度快。 创建一个项目&gt;管理&gt;部署公钥管理&gt;公钥管理&gt;添加个人共钥，把刚才在终端复制的公钥贴进来。 then可以把远程项目代码clone到本地了，克隆下载 &gt; 选择ssh，因为刚才已经添加过个人公钥了。 在用户目录下新建一个空文件夹用于存放项目，cd 到这个文件夹，git clone～～～，远程代码成功拉到本地。现在远程和本地已经建立起来了。 我们还需要添加一个.gitignore文件，忽略我们不需要push到仓库的文件 1$ vim .gitignore 输入i进行编辑 1234.DS_Storenode_modulesdist*.log ESC :wq+回车 保存成功，push到远程 3.安装node.js和yarn安装过程非常简单，记得指定版本。（node的安装官网很详细） 为什么不用node自带的npm? 因为yarn安装速度快，这种快并不仅仅是服务器快，而且并行下载，还有牛掰的缓存机制，之前装过的包是走缓存的，可以断网使用，到秒装效果。 yarn与npm的语法对比 Yarn Npm yarn init npm init yarn npm install yarn global add xxx@x.x.x npm install xxx@x.x.x -g yarn add xxx@x.x.x npm install xxx@x.x.x –save yarn add xxx@x.x.x –dev npm install xxx@x.x.x –save-dev yarn remove xxx npm uninstall xxx –save(-dev) yarn run xxx npm run xxx 4.初始化项目上一步安装完了node和yarn，cd到项目文件夹，初始化yarn，提示出的信息我们可以不填写，走默认的。 1$ yarn init git st-&gt;git add .-&gt;git ca &quot;yarn init&quot;-&gt;git ps将文件推送到远程仓库 5.webpack的安装和配置5.1.webpack概念前端资源打包工具，html，css，脚本，字体等资源都会被看作一个模块，都会被打包到js里。 5.2.多版本共存的解决方案全局只能安装一个啦，俩项目又不想使用同一个版本怎么搞啦！为了避免冲突，我们不可能在全局安装两个版本的webpack，node_modules&gt;.bin下面有一个可执行的webpack文件，使用这种方式，可以避免影响。webpack的安装。cd到项目根目录，为了避免冲突，这里所用到的所有工具，我都安装在项目里，不在全局安装。 1$ yarn add webpack@3.10.0 --dev 5.3.entry在项目根目录下新建一个webpack.config.js, 12345678const path = require('path');module.exports = &#123; entry: './src/app.js', //这是需要打包的文件路径，配置react的时候会改为jsx后缀 output: &#123; path: path.resolve(__dirname,'./dist'), //打包到目标文件夹 filename: 'app.js' //打包成功后的文件命名方式 &#125;&#125; 可以在src&gt;app.js随便写点东西，测试一下webpack是不是打包成功了。(下面的命令貌似有点长，最后再解决这个问题) 1$ node_modules/.bin/webpack 成功打包js～ 5.4.html安装htmlwebpackplugin插件，最好是指定版本（另外你安装了啥都在package.json文件里，这是yarn为我们自动生成的） 1$ yarn add html-webpack-plugin@2.30.1 --dev 配置htmlwebpackplugin插件 1234567891011//在webpack.config.js里引入htmlwebpackplugin插件const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; . . . //接着刚才的入口出口 写htmlwebpackplugin的配置 plugin: [ new HtmlWebpackPlugin() ]&#125; 打包一次试试看看什么效果，打包方式同entry里的方法。dist文件夹下多一个index.html文件，它默认引入了dist&gt;app.js文件，但是看起来好像跟我们想要的不太一样，有些标签没加，比如视口大小没有定义等等。我们可以指定模版,在src文件夹下新建一个index.html把这个文件作为模版。 123456plugin: [ new HtmlWebpackPlugin(&#123; //引用模版文件,这个文件默认的输出就是dist&gt;index.html template: './src/index.html' &#125;)] 5.5.脚本5.5.1.ES6语法在项目根目录下安装babel相关的插件，用于打包ES6的语法 1$ yarn add babel-core@6.26.0 babel-preset-env@1.6.1 babel-loader@7.1.2 --dev 配置webpack.config.js 12345678910111213141516171819202122232425262728module.exports = &#123; entry: './src/app.js', //使用react之后，文件后缀是jsx,与入口文件后缀保持一致 output: &#123; path: path.resolve(__dirname,'./dist'), filename: 'app.js' &#125;, //babel的配置开始 module: &#123; rules: [ &#123; test:/\\.js$/, //使用react之后文件后缀改为了jsx exclude: /(node_modules)/, //对参数不做处理 use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ] &#125;, //babel配置结束 . . .&#125; 之后在src&gt;app.js里写入ES6语法的代码，之后打包，我们会发现dist&gt;app.js里面已经被转为ES5的语法了。 5.5.2 react语法处理（相对好搞的部分）项目根目录装插件 1$ yarn add babel-preset-react@6.24.1 --dev 配置webpack.config.js，在刚才配置babel的preset环境中添加react,把js文件后缀改为jsx就ok了。 1presets: ['env react'] 安装react，这是我们代码里要用的，不是生产工具 1$ yarn add react@16.2.0 react-dom@16.2.0 在src&gt;app.jsx下书写react代码，打包成功啦～ 5.6.样式需要配置style-loader，css-loader ，sass-loader 5.6.1 安装style-loader和css-loader1$ yarn add style-loader@0.19.1 css-loader@0.28.8 --dev 修改配置文件，在rules中的react语法后接着配置 123456789//style-loader与css-loader的配置信息&#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ]&#125;//style-loader与css-loader的配置信息结束 在src&gt;新建index.css,写点样式，在src&gt;app.jsx中引入css 1import './index.css' 打包成功，css被打包到dist&gt;app.js中，我测试的dist下的文件，样式生效～，但是以这种方式打包出来的样式要等到所有js加载完成之后css在执行，有可能会出现网页裸奔效果，所以，我们应该想办法把它单独放在一个css文件里，然后 打包后 dist&gt;app.js已经引入～ 安装extract-text-webpack-plugin 1$ yarn add extract-text-webpack-plugin@3.0.2 --dev 配置webpack.config.js，把刚才配置的css里的use改为下面的代码,另外需要引入，new插件 123456789101112131415161718192021222324252627282930//extract-text-webpack-plugin 引入const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; . . . module: &#123; rules: [ //react语法的处理 . . . //css文件的处理 &#123; test: /\\.css$/, //extract-text-webpack-plugin use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) //extract-text-webpack-plugin &#125; ] &#125;, plugin: [ //extract-text-webpack-plugin 生成文件的位置 new ExtractTextPlugin('index.css') //extract-text-webpack-plugin ]&#125; 打包成功，～，css自动被引入了， 5.6.2处理sass安装sass-loader 1$ yarn add sass-loader@6.0.6 --dev 在webpack.config.js的module里的css文件的处理后，添加 12345678//sass文件的处理&#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: ['css-loader','sass-loader'] &#125;)&#125; 在src下面新建一个scss文件，在app.jsx中引入这个文件，打包成功，成功，，，哎？尼玛，报错了。。。而且还是scss文件的语法错误，尼玛三行测试代码有错，不科学呐～ 一顿找。。 因为，sass-loader依赖node-sass和webpack,赶紧安装一下，此包安装的时间可真久， 1$ yarn add node-sass@4.7.2 --dev 这回打包成功了～ 5.7图片和静态文件的处理 这或许有点麻烦了 5.7.1 图片的配置安装url-loader,url-loader依赖file-loader 1$ yarn add file-loader@1.1.6 url-loader@0.6.2 --dev 在刚才的webpack.config.js中的sass文件处理后接着写 12345678910111213//图片的配置&#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 //小于这个大小的图片资源直接转成base64 name: 'resource/[name].[ext]' //文件打包后的位置 &#125; &#125; ]&#125; 可以试试一张图片是不是被打包成功了， 5.7.2 配置字体（font-Awesome）安装一个font-Awesome 1$ yarn add font-awesome 配置webpack.config.js，接着图片处理写 12345678910111213//字体的处理&#123; test: /\\.(eot|svg|ttf|woff|woff2|otf)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 name: 'resource/[name].[ext]' //文件打包后的位置 &#125; &#125; ]&#125; 打包成功，dist目录多了很多文件。 5.7.3 通用模块提取的插件在webpack.config.js的plugin中 1234567891011121314const webpack = require('webpack'); plugins: [ //处理html文件 . . . //独立css文件 new ExtractTextPlugin('css/[name].css'), //提出公共模块的插件 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'common', filename: 'js/base.js' //通用的文件被打包到这个文件里 &#125;)] 5.7.4 webpack-dev-server 自动刷新安装webpack-dev-server 1$ yarn add webpack-dev-server@2.9.7 --dev 在webpack .config.js的最后，在出口里，定一个一个公共路径，不然后字体文件找不到路径，因为服务器是从根目录开始找的 12345678output: &#123; path: path.resolve(__dirname,'./dist'), publicPath: '/dist/', filename: 'js/app.js'&#125;,devServer: &#123; port: 8086 //默认的8080端口可能会被占用，所以修改&#125; 之后每改动一次文件，浏览器是自动刷新的。 最后一步，在package.json中配置一些脚本，只是有些命令太长了， 1234\"scripts\": &#123; \"dev\": \"node_modules/.bin/webpack-dev-server\", \"dist\": \"node_modules/.bin/webpack -p\" //线上环境的打包&#125;, yarn run dev就可以开启本地服务，会默认打包的， 到此，一个简单的react开发环境搭完成，但是，，这并不是最终的，这只是最简单的配置，在开发过程中还会进行别的配置。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"搭建一个基于github和hexo的博客","slug":"hellohexo","date":"2017-01-12T14:00:09.000Z","updated":"2018-09-20T08:47:50.534Z","comments":true,"path":"2017/01/12/hellohexo/","link":"","permalink":"http://yoursite.com/2017/01/12/hellohexo/","excerpt":"","text":"这是我的第一篇博客，我只想用它来记录学习路程，之前项目遇见问题，我会查别人的博客，意识到了分享的重要性，于是开始将我的写作放到博客上来。如果有不对的地方，希望大家多多批评指正。 1.首先你需要安装git和node环境，假如你安装了node，npm是默认安装的。 2.安装hexo你可以先检查一下是否安装了hexo。 1$ hexo -v 如果没有输出版本号，接着安装 1$ npm i hexo -g 3.创建git仓库登陆你的git账号，建立一个仓库，这个仓库名字必须是 用户名.github.io,并且一个github账号只能注册一个博客地址。本文所有的用户名都代表你的github用户名 4.创建本地博客文件夹在你喜欢的任何地方创建一个文件夹，用来创建本地博客，打开终端，cd到这个文件夹，初始化hexo 1$ hexo init 这个过程有可能会报安装依赖失败的error，我在win10上没有遇见，在mac上遇见了，此时安装依赖，即执行 1$ npm install 初始化完成之后，你就可以在本地预览你的博客了，启动服务器，s是server的意思，即执行 1$ hexo s 在本地浏览器地址栏输入http://localhost:4000/可以本地预览你的作品。不过可能看起来似乎有点low。但后期是可以更改主题的。 5.将本地博客推送至远程git仓库找到本地博客文件夹，根目录的_config.yml，拉到最后修改一个配置，注意冒号后有一个空格，每个键名前是两个空格。末尾不要留下空格 1234deploy: type: git branch: master repository: https://github.com/用户名/用户名.github.io.git 开始准备上传 1$ hexo g 上传 1$ hexo d 我在此处出错了，执行下面命令 1$ npm i hexo-deployer-git 下载完依赖之后再次执行 1$ hexo d 上传成功，在浏览器上访问你的用户名.github.io,就可以访问了 6.如何增加博客？在你博客文件夹下运行终端，创建一篇文章 1$ hexo new 文章名字 找到根目录下的source/_posts文件夹，你刚创建的博客md文档就出现了，你就可以在这里编写你的博客了，写好之后你预览了没问题就可以上传 12$ hexo g $ hexo d 7.修改主题如果你不喜欢那种原生的田园风格，可以尝试更换主题，我采用的主题是https://github.com/litten/hexo-theme-yilia,具体配置方案上面有文档，需要注意的是头像的图片地址放在yilia/source下路径，具体你想放在哪里写在yilia/_config.yml配置文件里就行啦！另外这是主题的中文文档地址http://moxfive.coding.me/yelee/ 8.绑定域名 这个要看你想不想绑定了，我是之前就有购买域名，所以用在了这里 1.如果你的域名需要实名认证，请提前认证，大概需要两三天吧。 2.获取github的IP地址：终端 ping 用户名.github.io记录下IP地址，这个IP是要和你的域名绑定的。 3.我是在阿里云购买的域名，登录&gt;控制台&gt;域名&gt;解析&gt;添加记录 CNAME记录值是你的用户名.github.io A对应的记录值是你刚才ping到的IP地址 4.根目录下的&gt;_config.yml修改skip_render: CNAME 5.在你的本地的文件夹根目录&gt;source下创建一个没有后缀的，名为CNAME的文件，里面写上你的域名，注意写错了报404，之后hexo -gand hexo -d 之后大功告成。试试用你的域名访问你的博客吧！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]