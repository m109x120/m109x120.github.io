[{"title":"ES6","slug":"ES6","date":"2018-09-17T11:02:23.000Z","updated":"2018-10-28T13:45:04.621Z","comments":true,"path":"2018/09/17/ES6/","link":"","permalink":"http://yoursite.com/2018/09/17/ES6/","excerpt":"ES6 用最简短的言语，把所学知识分类归置，是一门艺术，现在学会了，将来会遗忘！","text":"ES6 用最简短的言语，把所学知识分类归置，是一门艺术，现在学会了，将来会遗忘！ 1.变量(let const) let 1.不能重复定义,但是var可以。 12345678var food = 'hamburger';var food = 'chicken';//打印chicken，ES5中，同一个变量名，后声明的会覆盖前声明的console.log(food);//ES6的时代let foodEs6 = 'steak';//会直接在这一行报错，不允许重复定义let foodEs6 = 'milk'; 2.大括号划分块级作用域，ES6之前函数划分作用域 1234567891011//ES5，函数的大括号划分作用域，但是ES6里，大括号就划分作用域if(true)&#123; var strES5 = 'ES5';&#125;//var声明的变量能log到console.log(strES5);if(true)&#123; let strEs6 = 'Es6';&#125;//报错, 不在同一个作用域console.log(strEs6); 应用实例：由这种现象，ES5的for循环里var的索引是不合理的，使用let会避免变量污染，另外for内的异步代码能获取到自增的索引 12345for(let i = 0;i&lt;arrr.length;i++)&#123; arr[i].onclick = function()&#123; //能log到i &#125;&#125; 3.let不存在变量提升，var存在 123456//ES5会对var ,function 关键字声明的变量进行预解析为undefinedconsole.log(name);var name = 'Grace';//报错，ES6，不对let做预解析console.log(hobby);let hobby = '前端'; 4.暂时性死区 一个大括号内存在let声明的变量，对该变量的赋值不能先于声明，必须先定义再赋值。否则报引用错误。 1234if(true)&#123; console.log(a);//Uncaught ReferenceError: a is not defined let a = 'Grace';&#125; 实际上暂时性死区更好地规范了javascript。 const 1.常量不允许”修改”。必须在声明的同时进行赋初值 12345678910const PI = 3.1415926;PI = 3.14;//报错//但是如果是一个数组你是可以push进去数据，但是无法改变数组本身const arr = [];arr.push('grace');arr = [];// 报错，不能重新修改arr的指向//假如我们不想让他push，可以选择冰冻,//可以试图修改不会报错，只是改不了const arr = Object.freeze(['first','second']); //但是这个冻结只能冻结第一层，假如是一个对象，对象里有个数组，我们依旧可以对它push 2.箭头函数 形式：(形参1,形参2…) =&gt; 表达式/语句 特征1:继承外层作用域 特征2:不能用做为构造函数 特征3:没有prototype属性 总结：一个阉割版的函数 12345678910111213//最简单的箭头函数let obj = &#123; introFn:(name,age) =&gt; &#123; console.log('hi,I am '+name,'I am '+age+' years old'); // 没有独立作用域，继承外层作用域，调用log出window console.log(this); &#125;&#125;obj.introFn('Grace',18);// 打印原型是undefinedconsole.log(obj.introFn.prototype);//报错obj.introFn不是一个构造函数new obj.introFn; 3.模板字符串(带标签) 之前用过，art-template，接触过ES6后觉得层次提升很多 12345678910111213141516171819202122232425262728293031323334//支持变量引入let tit = 'title';//支持数组循环let goodsList = ['Apple','ml','huawei'];//支持函数调用let getName = () =&gt; &#123; return '我是ES6新增剪头函数';&#125;let str = tpl`&lt;div&gt; &lt;h1 class='$&#123;tit&#125;'&gt;ES6新增字符串模板&lt;/h1&gt; &lt;h2&gt;1,支持变量引入(h1的className):$&#123;tit&#125;&lt;/h2&gt; &lt;h2&gt;2.支持函数调用:$&#123;getName()&#125;&lt;/h2&gt; &lt;h2&gt;3.支持数组循环&lt;/h2&gt; &lt;ul&gt; $&#123; goodsList.map((value,index)=&gt; `&lt;li&gt;我是：$&#123;value&#125;,第$&#123;index&#125;号商品 &lt;/li&gt;`).join('') &#125; &lt;/ul&gt;&lt;/div&gt;`;function tpl(strings,...values)&#123; //不用调用，可以执行 //字符串模板里的每一部分 console.log(strings); //模板里的所有数据 console.log(values);&#125;console.log(str.startWith('!'));//判断模板字符串是不是以！开头console.log(str.endWith('!'));//判断模板字符串是不是以！结尾console.log(str.include('!'));//判断模板字符串是不是包含！var star = '⭐️';console.log(star.repeat(5));//重复5次document.querySelector('body').innerHTML = str; 4.Promise对象 关键字：resolve，reject，then 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Promise的一般写法 let P1 = new Promise((resolve,reject)=&gt;&#123; //异步的代码块，一般是ajax请求 $.ajax(&#123; url: 'user/get_user_info.do', type: 'post', success(msg)&#123; resolve(msg); &#125;, error(err)&#123; reject(err); &#125; &#125;);&#125;).then((msg)=&gt;&#123; //ajax成功之后的处理放在了这里&#125;,(err)=&gt;&#123; //ajax失败之后走这里&#125;);//Promise的链式写法var P2 = new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url: '/user/get_user_info.do', type: 'post', success(res)&#123; resolve(res); &#125;, error(err)&#123; reject(err); &#125; &#125;);&#125;);var P3 = new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url: '/user/get_cart_product_count.do', type: 'post', success(res)&#123; resolve(res); &#125;, error(err)&#123; reject(err); &#125; &#125;);&#125;);P2.then((res)=&gt;&#123; //P2请求成功的处理程序 return P3;&#125;,(err)=&gt;&#123; //P2请求失败的处理程序&#125;).then((res)=&gt;&#123; //P3请求成功的处理程序&#125;,(err)=&gt;&#123; //P3请求失败的处理程序&#125;); 5.面向对象 1.类的创建 1234567891011class Animal&#123; constructor(name)&#123; this.name = name; &#125; getName()&#123; return this.name; &#125;&#125;//实例化一个类let dog = new Animal('husky');console.log(dog.getName()); 2.类的继承 123456789class Cat extends Animal&#123; constructor()&#123; super(); this.name = 'cat'; &#125;&#125;let cat = new Cat();//可以使用父类的方法console.log(cat.getName()); 3.对象的写法 123456789101112131415161718192021222324252627//ES5中var name = 'Grace'; age = 18;var obj = &#123; name:name, age:age, getName:function()&#123; return this.name; &#125;, getAge:function()&#123; return this.age; &#125;&#125;//ES6我们可以直接用属性名，let name = 'Grace'; age = 18;let obj = &#123; name, age, getName()&#123; return this.name; &#125;, //表达式可以作为方法名字，或者属性名字 ['get'+'Age']()&#123; return this.age; &#125;&#125; 4.Object扩展 1234//Object的扩展Object.keys(obj); //获取所有字段的名字Object.assign(&#123;a:1&#125;,&#123;a:2,b:3&#125;);//我们得到&#123;a:2,b:3&#125;,它是一个浅copy 5.Object.setPrototypeOf 1234567891011121314151617//在创建对象之后改变对象的prototypelet hobby = &#123; play()&#123; return 'react'; &#125;&#125;;let goodAt = &#123; play()&#123; return 'vue'; &#125;&#125;;let sunday = Object.create(hobby);//基于hobby创建sunday对象console.log(sunday.play());//reactconsole.log(sunday.getPrototypeOf === hobby);//trueObject.setPrototypeOf(sunday,goodAt);//修改sunday的原型为goodAtcosnole.log(sunday.play);//vueconsole.log(sunday.getPrototypeOf === goodAt);//true 6.解构赋值(数组，对象，字符串) 1.解构数组 ES5中 123456789//ES5中function skill()&#123; return ['react','vue'];&#125;var tmp = skill(), skill1 = tmp[0], skill2 = tmp[1];//输出vueconsole.log(skill2); ​ 在ES6中我们可以这么用 123let [skill1,skill2] = skill();//输出vueconsole.log(skill2); 2.解构对象 1234567function skill()&#123; return &#123;s0:'react',s1: 'vue',s3: 'angular'&#125;;&#125;let &#123;s0:skill0,s1,s3:skill2&#125; = skill();//skill0,skill2相当于给变量起别名(k:v解构模式),冒号右边的变量名才真正被赋值，s1是直接解构没有起别名console.log(s1);//vueconsole.log(skill2);//angular 解构字符串 12 7.函数参数的默认值123function skill(skill1='react',skill2='vue')&#123; return `$&#123;skill1&#125;+$&#123;skill2&#125;`;&#125; 8.spread,rest操作符12345678let hobby = ['滑板','书法'], hobbyAnother = ['react','vue',...hobby];//['react','vue','滑板','书法'];//把参数剩余部分都分给name,是数组的形式function getName(n1,n2,...name)&#123; //展开name数组 console.log(n1,n2,...name);&#125; 有了这个，apply和arguments也就基本上退休了！ 9.function-name1234let skill = function ()&#123;&#125;console.log(skill.name);//skilllet skill = function s()&#123;&#125;console.log(skill.name);//s,优先级更高 10.Object的is方法123456//ES5中+0 == -0；//true；+0 === -0；//true；NaN == NaN；//falseObject.is(NaN,NaN);//trueObject.is(+0,-0);//false 11.数组中的增强1.类数组转数组（Array.from）123456789let obj = &#123; '0':'唐', '1':'宋', '2':'元', length: 3&#125;//类数组对象要求非常苛刻let arr = Array.from(obj);console.log(arr); 2.将一组值转换为数组（Array.of）12var arr = Array.of(1,2,3);console.log(arr); 3.数组中符合条件的第一项 1234567var arr = [1,2,3,4,5,6,7,8,9,10];var item = arr.find(function(value,index arr)&#123; //它只会寻找符合条件的第一项 if(value%5==0&amp;&amp;value%6==0)&#123; return true; &#125;&#125;); 是否包含某个项 1console.log(arr.includes(10)); 4.for…of…与entries, keys,valueskeys 1234var arr = ['a','b'];for(let k of arr.keys())&#123; console.log(k);//0,1&#125; entries 123for(let [k,v] of arr.entries)&#123; console.log(k,v);&#125; try…catch…(不能捕获异步的异常) 123456try&#123; throw new Error(\"错误\"); //当try里面出现错误的时候，不会直接抛向控制台影响程序执行，而是传给catch，让catch区捕获&#125;catch(exp)&#123; console.log(exp);&#125; 一个try…catch的实例，在解决兼容性问题的时候充当能力检测 123456789try&#123; oDiv.addeventlistener('click',function()&#123; //低版本IE不支持，会直接走下面的绑定形式 &#125;,false);&#125;catch(exp)&#123; oDiv.attachEvent('onclick',function()&#123; &#125;)&#125; 数组中的map(不是很常用) 12345let arr = [1,2,3];let arr2 = arr.map(function(item)&#123; return item*item;&#125;);console.log(arr2);//[1,4,9]","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"react基本语法特征","slug":"react-basic-928-0","date":"2018-03-28T03:51:13.000Z","updated":"2018-10-20T05:41:12.023Z","comments":true,"path":"2018/03/28/react-basic-928-0/","link":"","permalink":"http://yoursite.com/2018/03/28/react-basic-928-0/","excerpt":"总结一下基本的react语法，以及特有的jsx，组件传值，包括子组件修改父组件的数据，兄弟组件的通信，实际上也就是单向数据流的概念。","text":"总结一下基本的react语法，以及特有的jsx，组件传值，包括子组件修改父组件的数据，兄弟组件的通信，实际上也就是单向数据流的概念。 1.react的优点react本身只是一个视图层的框架，它抛弃了传统的继承模式，采用组件化的方式开发，采用了jsx表达式，jsx只有在react里才有的，用来处理数据和DOM的关系，不需要我们操作DOM，我们所关心的是数据，dom也是由数据在驱动，不同于art-template等之类的模版字符串，它采用虚拟DOM的方式减少低效的DOM操作。 2.jsx基础语法 基本用法，样式用法，变量的使用，逻辑的处理 1234567891011121314151617181920212223242526272829//导入react，react-domimport React from 'react';import ReactDOM from 'react-dom';let obj = &#123; name: 'Grace', flag: true&#125;;let arr = ['Apple','ml','oppo'];let style = &#123; color:'r'+'ed', fontSize: 30+20+'px' //虽然直接加样式的方式不常用，但它支持逻辑，&#125;;let jsx = ( &lt;div style=&#123;style&#125; className='jsx'&gt; &#123;/*条件判断与变量的使用*/&#125; &#123; obj.flag ? &lt;p&gt;I am &#123;obj.name&#125;&lt;/p&gt; : &lt;p&gt;I am not &#123;obj.name&#125;&lt;/p&gt; &#125; &#123;/*数组循环*/&#125; &#123; arr.map((name,index) =&gt; &lt;p key=&#123;index&#125;&gt;第&#123;index&#125;号商品:&#123;name&#125;&lt;/p&gt;) &#125; &lt;/div&gt;);ReactDOM.render( jsx, document.querySelector('#app')); 3.react组件（ES6）本段代码包含，数据传递，修改数据，以及事件绑定 123456789101112131415161718192021222324252627282930313233343536373839class Compontent extends React.Component&#123; constructor(props)&#123; //父组件向子组件传递数据 super(props); this.state = &#123; age: 18 &#125; &#125; handelClick()&#123; //修改自身的数据 this.setState(&#123; age : this.state.age+1 &#125;); &#125; handelChange(e)&#123; this.setState(&#123; age : e.target.value &#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;I am &#123;this.props.name&#125;,我今年 &#123;this.state.age&#125; 岁了&lt;/h1&gt; &#123;/*在事件绑定上使用了箭头函数，这是利用了，ES6箭头函数自身没有this的概念，它继承自父类 的 this，正好使用这种方式，我们无需重新绑定this*/&#125; &lt;button onClick=&#123;(e)=&gt;&#123;this.handelClick(e)&#125;&#125;&gt;加一岁&lt;/button&gt; &lt;input type=\"text\" onChange=&#123;(e)=&gt;&#123;this.handelChange(e)&#125;&#125;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( //只能是一层 &lt;div&gt; &lt;Compontent name='Grace'/&gt; &lt;Compontent name='Jack'/&gt; &lt;/div&gt;, document.querySelector('#app')); 4. 组件之间的关系容器式与单纯组件写法123456789101112131415161718192021222324252627282930313233343536class Compontent extends React.Component&#123; render()&#123; return ( &lt;h2&gt;Compontent&lt;/h2&gt; ) &#125;&#125;class Title extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;h1&gt;&#123;this.props.children&#125;&lt;/h1&gt; ) &#125;&#125;class App extends React.Component&#123; render()&#123; return( &lt;div className=''&gt; &#123;/*容器式组件*/&#125; &lt;Title&gt; &lt;h2&gt;App h2&lt;/h2&gt; &lt;/Title&gt; &lt;hr/&gt; &#123;/*单纯组件*/&#125; &lt;Compontent/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;App /&gt;, document.querySelector('#app')); 我们发现，父组件向子组件传值很方便，通过props，但是子组件向父组件传值如何实现？兄弟组件呢？ 5. 组件传值5.1父组件向子组件传值：props5.2子组件修改父组件的值其实，我们没办法在子组件里修改父组件的值，props传来的数据是只读的，但是我们可以告诉父组件我想让你帮我把某个数据改掉，这个我们可以通过回调来处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 父子组件的数据通信// 子组件想要改变父组件的样式class Children extends React.Component&#123; constructor(props)&#123; super(props); &#125; handelClick(e)&#123; // 我们可以通过props得到父组件传来的fontColor // console.log(this.props.bgColor); // 我们无法直接修改props，因为它是只读数据 // 我们可以采用回调的形式，来告诉父组件，我想要修改某个值，而实际上还是虽然是在子组件里面点击了按 //钮，但是触发修改数据的是父组件，因为单向数据流，数据在父组件身上呢。 this.props.colorChange('red'); &#125; render()&#123; return ( &#123;/*第一层大括号是表达式，第二层大括号是json结构*/&#125; &lt;div style=&#123;&#123;background:this.props.bgColor&#125;&#125;&gt; &lt;button onClick=&#123;(e)=&gt;&#123;this.handelClick(e)&#125;&#125;&gt;改变父组件的bgColor颜色 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class Father extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123; bgColor : 'green' &#125; &#125; onBgColorChange(color)&#123; // color值是从子组件传来的，只要有值传过来，就能触发这个事件 this.setState(&#123; bgColor: color &#125;) &#125; render()&#123; return( &lt;div style=&#123;&#123;background:this.state.bgColor&#125;&#125;&gt; &lt;h1&gt;父组件背景色：&#123;this.state.bgColor&#125;&lt;/h1&gt; &#123;/* 调用子组件，并传值进去 */&#125; &lt;Children colorChange=&#123;(color)=&gt;&#123;this.onBgColorChange(color)&#125;&#125;/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Father/&gt;, document.querySelector('#app')); 5.3兄弟组件传值用到了变量提升，把需要更改的值，以及更改操作都放在父组件里。因为单项数据流的原因，当父组件的值发生改变，会向下传递到子组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Children1 extends React.Component&#123; // 接收父组件传值 constructor(props)&#123; super(props); &#125; handelClick()&#123; this.props.changeChild2Color('yellow'); &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;child1:&lt;/h2&gt; &lt;button onClick=&#123;(e)=&gt;&#123;this.handelClick(e)&#125;&#125;&gt;改变child2的背景颜色&lt;/button&gt; &lt;hr/&gt; &lt;/div&gt; ) &#125;&#125;class Children2 extends React.Component&#123; // 接收组件传来的值 constructor(props)&#123; super(props); &#125; render()&#123; return ( &lt;div style=&#123;&#123;color:this.props.bgColor&#125;&#125;&gt; &lt;h2&gt;child2: &#123;this.props.bgColor&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;class Father extends React.Component&#123; constructor(props)&#123; super(props); // 把应该在child2里的数据保存在父组件中，叫状态提升 this.state = &#123; child2BgColor: 'red' &#125; &#125; changeColor(color)&#123; // console.log(color); yellow传过来了 this.setState(&#123; child2BgColor: color &#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;Children1 changeChild2Color=&#123;(color)=&gt;&#123;this.changeColor(color)&#125;&#125;/&gt; &lt;Children2 bgColor=&#123;this.state.child2BgColor&#125;/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Father/&gt;, document.querySelector('#app')); 6.react声明周期生命周期是一个组件从生到死的整个过程 6.1Mounting挂载(渲染)阶段最先出现的是： 1constructor()&#123;&#125; 组件将要渲染： 1componentWillMount()&#123;&#125; 组件渲染： 1render()&#123;&#125; 组件渲染完成： 1componentDidMount()&#123;&#125; 简单测试一下 12345678910111213141516171819class Test extends React.Component&#123; constructor(props)&#123; super(props); console.log('Mount: constructor'); &#125; componentWillMount()&#123; console.log('Mount: componentWillMount'); &#125; componentDidMount()&#123; console.log('Mount: componentDidMount'); &#125; render()&#123; console.log('render'); return ( &lt;h1&gt;hahah&lt;/h1&gt; ); &#125;&#125; 执行结果：Mount: constructor-&gt;Mount: componentWillMount-&gt;render-&gt;Mount: componentDidMount 6.2 Updating运行时阶段(组件更新引起的变化)自更新是没有钩子的，只有是父组件修改数据才能触发 将要接收父组件传来的props 1componentWillReceiveProps()&#123;&#125; 子组件是否需要更新 1234shouldComponentUpdata()&#123; //这个方法返回false后面的都不再执行 return true;&#125; 子组件将要更新 1compontentWillUpdata()&#123;&#125; 子组件更新 1render()&#123;&#125; 子组件更新完成 1compontentDidUpdate()&#123;&#125; 同样测试一下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Test extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; content: 'haha' &#125; console.log('Mount: constructor'); &#125; componentWillMount()&#123; console.log('Mount: compontentWillMount'); &#125; handelClick()&#123; this.props.changeContent('Grace'); &#125; render()&#123; console.log('render'); return ( &lt;h1 onClick=&#123;()=&gt;&#123;this.handelClick()&#125;&#125;&gt;&#123;this.props.content&#125;&lt;/h1&gt; ); &#125; componentDidMount()&#123; console.log('Mount: compontentDidMount'); &#125; componentWillReceiveProps()&#123; console.log('Updating: componentWillReceiveProps'); &#125; shouldComponentUpdate()&#123; console.log('Updating: shouldComponentUpdate'); return true; &#125; componentDidUpdate()&#123; console.log('Updating: componentDidUpdate'); &#125;&#125;class F extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; content: 'haha' &#125; &#125; setContent(context)&#123; this.setState(&#123; content: context &#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;Test content=&#123;this.state.content&#125; changeContent=&#123;(context)=&gt;&#123;this.setContent(context)&#125;&#125;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;F/&gt;, document.querySelector('#app')); 执行结果：Updating: componentWillReceiveProps-&gt;Updating: shouldComponentUpdate-&gt;render-&gt;Updating: componentDidUpdate 6.3Unmounting卸载阶段组件将要销毁 123compontentWillUnmount()&#123; //如果做了定时器，在销毁前要清定时器，以减少性能消耗&#125; 6.4Error Handing错误处理(react16独有)这种错误并不是逻辑错误，只处理在render时候的错误 还有其他非常重点的东西，下次总结路由：React-Router ，很有意思，牵扯的历史的东西也是很多。react生态系统很庞大，有一定的学习成本","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"jsx","slug":"jsx","permalink":"http://yoursite.com/tags/jsx/"},{"name":"react组件传值","slug":"react组件传值","permalink":"http://yoursite.com/tags/react组件传值/"},{"name":"生命周期","slug":"生命周期","permalink":"http://yoursite.com/tags/生命周期/"}]},{"title":"react开发打包环境的搭建","slug":"reactProductEnvironment","date":"2018-03-18T14:30:07.000Z","updated":"2018-10-20T05:31:17.030Z","comments":true,"path":"2018/03/18/reactProductEnvironment/","link":"","permalink":"http://yoursite.com/2018/03/18/reactProductEnvironment/","excerpt":"总结一下搭建react开发环境基本过程，以及在搭建过程中遇见的大坑，小坑。。。","text":"总结一下搭建react开发环境基本过程，以及在搭建过程中遇见的大坑，小坑。。。 1.git的安装和配置 git安装(想必都会，只总结mac系统遇到的问题) 官网下载git的.dmg安装包，双击打开，双击.pkg的安装包，😯，报错了…打不开身份不明开发者。这是由于mac安全限制外部下载的软件。 解决方案：打开系统偏好设置&gt;安全与隐私&gt;通用：提示已阻止打开“git-…pkg”,因为来自身份不明的开发者。倔强地选择仍要打开。 接着傻瓜式下一步…ok。 检测是不是安装成功了(成功输出git的版本号) 1$ git --version 配置.gitconfig(它是一个用户目录下的隐藏文件，终端ls看不见隐藏文件，ls -all可以看见) 1$ vim ~/.gitconfig 进来之后，用小写字母i进入编辑模式，user不配置首次提交的时候也会让你输入，这里的email是注册git的时候使用的邮箱。alias是git命令简写，我只配了一些常用的。⚠️等号两边不要加空格呀！ 123456789101112[user] name=Grace email=***@163.com[alias] co=checkout ci=commit st=status pl=pull ps=push dt=difftool ca=commit -am b=branch 写好之后按ESC推出编辑模式，输入:wq+回车保存并退出.gitconfig的编辑模式，我们还可以查看刚才的配置信息。 1$ cat ~/.gitconfig 2.项目的建立 获取ssh密钥邮箱是刚才配置的那个，执行完这条命令之后，一直回车到执行完 1$ ssh-keygen -t rsa -C '***@163.com' 此时会在用户目录下生成一个.ssh的文件夹，cd到这个文件夹,ls-all查看所有文件，那个id_rsa.pub就是存放公钥的文件 1$ cat id_rsa.pub 查看公钥内容，复制下来。 打开gitee.com，码云在国内，速度快。 创建一个项目&gt;管理&gt;部署公钥管理&gt;公钥管理&gt;添加个人共钥，把刚才在终端复制的公钥贴进来。 then可以把远程项目代码clone到本地了，克隆下载 &gt; 选择ssh，因为刚才已经添加过个人公钥了。 在用户目录下新建一个空文件夹用于存放项目，cd 到这个文件夹，git clone～～～，远程代码成功拉到本地。现在远程和本地已经建立起来了。 我们还需要添加一个.gitignore文件，忽略我们不需要push到仓库的文件 1$ vim .gitignore 输入i进行编辑，上传的是源码。 1234.DS_Storenode_modulesdist*.log ESC :wq+回车 保存成功，push到远程 3.安装node.js和yarnNode.js安装过程非常简单，记得指定版本。（node的安装官网很详细） 为什么不用node自带的npm? 因为yarn安装速度快，这种快并不仅仅是服务器快，而且并行下载，还有牛掰的缓存机制，之前装过的包是走缓存的，可以断网使用，达到秒装效果。yarn的版本锁定机制是严格的，而npm是按照版本范围来的。 我们可以使用npm来安装yarn， 1$ npm i yarn -g yarn与npm的语法对比 Yarn Npm yarn init npm init yarn npm install yarn global add xxx@x.x.x npm install xxx@x.x.x -g yarn add xxx@x.x.x npm install xxx@x.x.x yarn add xxx@x.x.x –dev npm install xxx@x.x.x -dev yarn remove xxx npm uninstall xxx (-dev) yarn run xxx npm run xxx 4.初始化项目上一步安装完了node和yarn，cd到项目文件夹，初始化yarn，提示出的信息我们可以不填写，走默认的。 1$ yarn init git st-&gt;git add .-&gt;git ca &quot;yarn init&quot;-&gt;git ps将文件推送到远程仓库 5.webpack的安装和配置5.1.webpack概念前端资源打包工具，html，css，脚本，字体等资源都会被看作一个模块，都会被打包到js里。 5.2.多版本共存的解决方案全局只能安装一个啦，俩项目又不想使用同一个版本怎么搞啦！为了避免冲突，我们不可能在全局安装两个版本的webpack，node_modules&gt;.bin下面有一个可执行的webpack文件，使用这种方式，可以避免影响。webpack的安装。cd到项目根目录，为了避免冲突，这里所用到的所有工具，我都安装在项目里，不在全局安装。 1$ yarn add webpack@3.10.0 --dev 5.3.entry在项目根目录下新建一个webpack.config.js，配置信息重要看官方文档 12345678const path = require('path');module.exports = &#123; entry: './src/app.js', //这是需要打包的文件路径，配置react的时候会改为jsx后缀 output: &#123; path: path.resolve(__dirname,'./dist'), //打包到目标文件夹 filename: 'app.js' //打包成功后的文件命名方式 &#125;&#125; 可以在src&gt;app.js随便写点东西，测试一下webpack是不是打包成功了。(下面的命令貌似有点长，最后再解决这个问题) 1$ node_modules/.bin/webpack 成功打包js～ 5.4.html安装htmlwebpackplugin插件，最好是指定版本（另外你安装了啥都在package.json文件里，这是yarn为我们自动生成的） 1$ yarn add html-webpack-plugin@2.30.1 --dev 配置htmlwebpackplugin插件 123456789101112//在webpack.config.js里引入htmlwebpackplugin插件const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; . . . , //接着刚才的入口出口 写htmlwebpackplugin的配置 plugin: [ new HtmlWebpackPlugin() ]&#125; 打包一次试试看看什么效果，打包方式同entry里的方法。dist文件夹下多一个index.html文件，它默认引入了dist&gt;app.js文件，但是看起来好像跟我们想要的不太一样，有些标签没加，比如视口大小没有定义等等。我们可以指定模版,在src文件夹下新建一个index.html把这个文件作为模版。 123456plugin: [ new HtmlWebpackPlugin(&#123; //引用模版文件,这个文件默认的输出就是dist&gt;index.html template: './src/index.html' &#125;)] 5.5.脚本5.5.1.ES6语法在项目根目录下安装babel相关的插件，用于打包ES6的语法 1$ yarn add babel-core@6.26.0 babel-preset-env@1.6.1 babel-loader@7.1.2 --dev 配置webpack.config.js 12345678910111213141516171819202122232425262728module.exports = &#123; entry: './src/app.js', //使用react之后，文件后缀是jsx,与入口文件后缀保持一致 output: &#123; path: path.resolve(__dirname,'./dist'), filename: 'app.js' &#125;, //babel的配置开始 module: &#123; rules: [ &#123; test:/\\.js$/, //使用react之后文件后缀改为了jsx exclude: /(node_modules)/, //对参数不做处理 use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ] &#125;, //babel配置结束 . . .&#125; 之后在src&gt;app.js里写入ES6语法的代码，之后打包，我们会发现dist&gt;app.js里面已经被转为ES5的语法了。 5.5.2 react语法处理（相对好搞的部分）项目根目录装插件 1$ yarn add babel-preset-react@6.24.1 --dev 配置webpack.config.js，在刚才配置babel的preset环境中添加react,把js文件后缀改为jsx就ok了。 1presets: ['env','react'] 安装react，这是我们代码里要用的，不是生产工具 1$ yarn add react@16.2.0 react-dom@16.2.0 在src&gt;app.jsx下书写react代码，打包成功啦～,注意这个时候就webpack.config.js里的配置应该改为jsx后缀名了。 5.6.样式需要配置style-loader，css-loader ，sass-loader 5.6.1 安装style-loader和css-loader1$ yarn add style-loader@0.19.1 css-loader@0.28.8 --dev 修改配置文件，在rules中的react语法后接着配置 123456789//style-loader与css-loader的配置信息&#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ]&#125;//style-loader与css-loader的配置信息结束 在src&gt;新建index.css,写点样式，在src&gt;app.jsx中引入css 1import './index.css' 打包成功，css被打包到dist&gt;app.js中，我测试的dist下的文件，样式生效～，但是以这种方式打包出来的样式要等到所有js加载完成之后css在执行，有可能会出现网页裸奔效果，所以，我们应该想办法把它单独放在一个css文件里，然后 打包后 dist&gt;app.js已经引入～ 安装extract-text-webpack-plugin 1$ yarn add extract-text-webpack-plugin@3.0.2 --dev 配置webpack.config.js，把刚才配置的css里的use改为下面的代码,另外需要引入，new插件 123456789101112131415161718192021222324252627282930//extract-text-webpack-plugin 引入const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; . . . module: &#123; rules: [ //react语法的处理 . . . //css文件的处理 &#123; test: /\\.css$/, //extract-text-webpack-plugin use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) //extract-text-webpack-plugin &#125; ] &#125;, plugins: [ //extract-text-webpack-plugin 生成文件的位置 new ExtractTextPlugin('index.css') //extract-text-webpack-plugin ]&#125; 打包成功，～，css自动被引入了， 5.6.2处理sass安装sass-loader 1$ yarn add sass-loader@6.0.6 --dev 在webpack.config.js的module里的css文件的处理后，添加 12345678//sass文件的处理&#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: ['css-loader','sass-loader'] &#125;)&#125; 在src下面新建一个scss文件，在app.jsx中引入这个文件，打包成功，成功，，，哎？尼玛，报错了。。。而且还是scss文件的语法错误，尼玛三行测试代码有错，不科学呐～ 一顿找。。 因为，sass-loader依赖node-sass和webpack,赶紧安装一下，此包安装的时间可真久， 1$ yarn add node-sass@4.7.2 --dev 这回打包成功了～ 5.7图片和静态文件的处理 这或许有点麻烦了 5.7.1 图片的配置安装url-loader,url-loader依赖file-loader 1$ yarn add file-loader@1.1.6 url-loader@0.6.2 --dev 在刚才的webpack.config.js中的sass文件处理后接着写 12345678910111213//图片的配置&#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, //小于这个大小的图片资源直接转成base64 name: 'resource/[name].[ext]' //文件打包后的位置 &#125; &#125; ]&#125; 可以试试一张图片是不是被打包成功了， 5.7.2 配置字体（font-Awesome）安装一个font-Awesome 1$ yarn add font-awesome 配置webpack.config.js，接着图片处理写 12345678910111213//字体的处理&#123; test: /\\.(eot|svg|ttf|woff|woff2|otf)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, name: 'resource/[name].[ext]' //文件打包后的位置 &#125; &#125; ]&#125; 打包成功，dist目录多了很多文件。 5.7.3 通用模块提取的插件在webpack.config.js的plugin中 123456789101112131415const webpack = require('webpack'); plugins: [ //处理html文件 . . . //独立css文件 new ExtractTextPlugin('css/[name].css'), //提出公共模块的插件 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'common', filename: 'js/base.js' //通用的文件被打包到这个文件里 &#125;)]//可以规划一下打包文件路径 规划完路径之后会找不到静态资源是怎么回事呢？ 5.7.4 webpack-dev-server 自动刷新安装webpack-dev-server 1$ yarn add webpack-dev-server@2.9.7 --dev 在webpack .config.js的最后，在出口里，定义一个公共路径，不然后字体文件找不到路径，因为服务器是从根目录开始找的 12345678output: &#123; path: path.resolve(__dirname,'dist'), publicPath: '/dist/', filename: 'js/app.js'&#125;,devServer: &#123; port: 8086 //默认的8080端口可能会被占用，所以修改&#125; 启动服务： 1$ node_modules/.bin/webpack-dev-server 之后每改动一次文件，浏览器是自动刷新的。 最后一步，在package.json中配置一些脚本，只是有些命令太长了， 1234\"scripts\": &#123; \"dev\": \"node_modules/.bin/webpack-dev-server\", \"dist\": \"node_modules/.bin/webpack -p\" //线上环境的打包&#125;, yarn run dev就可以开启本地服务，会默认打包的， 到此，一个简单的react开发环境搭完成，但是，，这并不是最终的，这只是最简单的配置，在开发过程中还会进行别的配置。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"使用Express开发MVC应用","slug":"express-node","date":"2018-02-09T12:20:55.000Z","updated":"2018-10-21T14:37:18.438Z","comments":true,"path":"2018/02/09/express-node/","link":"","permalink":"http://yoursite.com/2018/02/09/express-node/","excerpt":"后端渲染静态页是最有利于SEO的做法，经过后端渲染出的页面包含真实的数据，有利于爬虫抓取，但，牵扯到数据很多的情况下，会加重服务器的负担，服务端响应请求的速度会变慢。这里采用node的express，说说MVC开发模式。","text":"后端渲染静态页是最有利于SEO的做法，经过后端渲染出的页面包含真实的数据，有利于爬虫抓取，但，牵扯到数据很多的情况下，会加重服务器的负担，服务端响应请求的速度会变慢。这里采用node的express，说说MVC开发模式。 0.起步，搭建MVC结构1234# 初始化 package.json 文件npm init -y# 安装 express 到项目中npm i express 定义app.js为程序入口文件 123456789101112131415// 1. 加载 Expressconst express = require('express');//加载路由模块const router = require('./router');// 2. 调用 express() 得到一个 app//类似于 http.createServer()const app = express();// 3.挂载路由，app.use(router);// 4. 监听端口号，启动 Web 服务app.listen(3000, () =&gt; &#123; console.log('server is runing on localhost:3000');&#125;); 路由模块rooter.js 12345678910const express = require('express');//导入来自控制器的方法；假如说来自控制器的用户模块const c_user = require('./controllers/c_user');const router = express.Router();//router的回调函数会被独立到controllers/c_user模块（控制器模块中）router.get('/', c_user.handelLogin);//将路由模块导出module.exports = router; 控制器模块controllers/c_user.js（以处理用户登录为例，数据库处理的模块要放在model层） 123456789101112131415161718192021222324252627282930//导入来之model层的数据库方法const m_user = require('../models/m_user');module.exports.handelLogin = (req,res)=&gt;&#123; //获取前端表单发来的数据，这个需要配置app.js,这个body是一个对象，有的时候数据库里的字段不一定都来自表单，有可能要手动添加 const body = req.body; // 调用model层方法 得到数据库操作的方法 m_user.checkEmail(body,(err,data)=&gt;&#123; if(err)&#123; //其实错误处理，以及错误界面这种最后都会在中间件中处理 return res.send(&#123; code:500, msg:'服务端发生错误' &#125;); &#125; . . . //将当前登录成功的用户所有信息都种到session中 req.session.user = data[0]; //session的清除也很简单 //delete req.session.user; //后端重定向 res.redirect('/'); res.send(&#123; code:200, msg:'登录成功' &#125;); &#125;);&#125; 0.1:const body = req.body能直接获取到前端发来的数据？这真不是有一点便利 123456//先安装bodyParser//在程序入口app.js中配置bodyParsesrconst bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123; extended:false&#125;)); 这个req.body是非常好用的。比如说数据库添加，验证数据成功之后，可以使用如下方式进行数据库添加 1234567const sql = `INSERT INTO users SET ?`;db.query(sql,req.body,(err,data)=&gt;&#123; if(err)&#123; return callback(err,null); &#125; callback(null,data);&#125;); 0.2:回调函数获取model层数据库操作得到的数据（以查询用户表为例） 123456789101112//导入数据库的有关配置信息，配置信息独立到一个模块中tools/db.js模块const db = require('../tools/db_config');module.exports.getAllTopics = function(callback)&#123; const sql = 'SELECT * FROM `users`'; db.query(sql,(err,data)=&gt;&#123; if(err)&#123; return callback(err,null); &#125; callback(null,data); &#125;);&#125; 其实，一开始的时候就遇见一个bug，就是我们正常关闭数据库，会报错，Cannot enqueue Handshake after invoking quit.这是因为数据库操作是异步的，也就是js执行到query时，并不会执行query，而是先执行关闭，再去执行sql语句，会报错，最后会把连接方式改为链接池的方式进行连接。 先看看mysql的配置信息（tools/db.js） 123456789101112//安装mysql//mysql的配置，只在db模块导入const mysql = require('mysql');const db = mysql.createConnection(&#123; host: 'localhost', // 要连接的主机名 user: 'root', // 要连接的数据库的用户名 password: 'pwd', // 数据库密码 database: 'dbName' // 数据库&#125;);module.exports = db; 看到这种回调函数获取异步结果的用处，就不免想起jsonp的牛掰机制。下回总结一下jsonp的原理。 0.3:有关session会话机制12345678910//安装express-sessionconst session = require('express-session');//配置session//配置sessionapp.use(session(&#123; secret: 'keyboard cat', resave: false, saveUninitialized: true, cookie: &#123; secure: true &#125;&#125;)); 其实这种方式并不是持久化保存的。每次重启服务器，都需要重新登录。 express-mysql-session:把express-session保存的信息保存到数据库里（配置看官方https://github.com/chill117/express-mysql-session） 12#安装$ npm i express-mysql-session 1.静态界面渲染 起步模块，也就大致搭建好了MVC的结构，说到这里你或许还没看到如何处理静态资源的 安装express-art-template，这就是art-template比较厉害的地方了，不仅支持前端渲染，还支持后端渲染，不得不说的是，使用art-template进行前端渲染我们查看网页源代码是看不到数据的，都是双花括号之类的字符串，数据都是通过请求得到的，这样非常不利于SEO。 安装，express-art-template依赖art-template所以安装两个 1$ npm install art-template express-art-template 配置与使用在app.js模块 12345// 1. 导包const artTemplate = require('art-template');const app = express();app.engine('html', require('express-art-template')); 1.1art-template使用 art-template算是经常使用，但是每次用到都会去文档看看，年龄大了，脑子都不好使，记不住。。。 1.1.1循环模板传入的数据必须是json对象，注意数据库里得到的是数组，需要包一层json格式。假定是：{‘list’:arr} 12345&#123;&#123;each list&#125;&#125; ... &#123;&#123;$value.name&#125;&#125; ...&#123;&#123;/each list&#125;&#125; 1.1.2判断123456789&#123;&#123;if list.length==0&#125;&#125; 没有数据&#123;&#123;else&#125;&#125; &#123;&#123;each list&#125;&#125; ... &#123;&#123;$value.name&#125;&#125; ... &#123;&#123;/each&#125;&#125;&#123;&#123;/if&#125;&#125; 前端调用函数 1const str = template('id',&#123;'list':arr&#125;); 后端调用函数 123 res.render('index.html',&#123;'list':data&#125;);//index.html是views下的视图层文件，我们安装配置完express-art-templates之后res就有了这个方法//而且这个方法很牛掰，直接返给浏览器渲染 1.2.静态外链文件的处理 我们要给views下的html页面添加css，js，图片等静态资源，新建public文件夹, 里面存放资源文件,如css文件、图片素材等。 然后在index.html中通过link引入 css文件, 发现加载不到, 浏览器控制台报404 如何解决这个问题呢? 因为：任何请求都要通过配置路由的方式去处理，但其实路由转发或许是个方案，但是，资源太多处理起来就会很麻烦，所以，直接采用开放静态资源的方法。 1234//公开/public下的所有静态资源app.use('/public', express.static('./public/'));// 开放项目中要使用的第三方包app.use('/node_modules', express.static('./node_modules/')); 接下来我们可以直接在静态资源文件里引入开放出来的静态资源了 123456&lt;!-- 使用静态外链资源 --&gt;&lt;link rel=\"stylesheet\" href=\"../public/main.css\"&gt;&lt;!-- 使用第三方包中的资源 --&gt;&lt;script src=\"/node_modules/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;!--使用自己公开的静态js资源--&gt;&lt;script src=\"/public/index.js\"&gt;&lt;/script&gt; 。其实在接触node之前，有人告诉我，node就像小麦收割机，可以突突突地收麦子，而其他就像镰刀。接触过之后觉得，node是造收割机比较便利，零件都好了，直接拿来组装就好。前端学node最大的优势可能就是熟悉JS语法吧。不过由于后台业务逻辑复杂性，怎么写看起来都像翔。 1.3时间安装处理时间的包,前后端都能使用（moment.js.com） 1$ npm install moment 配置看官方文档 12const moment = require('moment');body.createAt = moment().format(); 2.动态路由在html中 1&lt;a href='/topic/&#123;&#123;$value.id&#125;&#125;'&gt;&lt;/a&gt; 路由router.js模块中接收参数 1router.get('/topic/:topicId'); 控制器中获取参数，前端获取还需要截取，存储，这个方法真的神清气爽，非常好用。 1req.params;//这直接就是&#123;topicId:***&#125; 根据当前的动态路由携带参数，渲染界面。 3.中间件使用中间件可以统一对路由进行处理，第一个参数不写，代表不限定请求标识。例如，我们每个界面都要判断用户是否登录，使用中间件就非常的方便。 123456//所有路由都会匹配到这里app.use((req,res,next)=&gt;&#123; console.log(`请求方式：$&#123;req.method&#125;,请求地址是：$&#123;req.url&#125;`); //继续匹配下一个可以匹配到的中间件 next();&#125;); 实际上我们只是在app.js配置express-session但是在很多地方都可以使用啦，这底层就是运用了中间件的原理。 中间件使用例子： 登录验证，在挂载路由之前，配置session之后， 1234567//使用中间件获取当前登录的用户信息,任意请求都能进来app.use((req,res,next)=&gt;&#123; req.locals.userInfo = req.session.user; //如此以来就可以做登录处理了，可以在模版引擎里直接使用userInfo了 next(); //next不写全部都被拦截到这里了&#125;) 404错误界面，挂载路由之后 1234567891011121314// 当前面没有任何一个中间件能处理该请求时,则会进入到下面的这个中间件// 不关心请求标识和请求方法app.use((req, res, next) =&gt; &#123; res.render(\"404.html\"); //调用next（）就是在调用下一个能匹配的中间件 //如果next()传了参数，会自动调用下一个处理函数有四个参数的中间件 //next的参数是err对象 try&#123; JSON.parse('asdf'); &#125;catch(err)&#123; //利用try函数时图捕获一个错误 next(err); &#125;&#125;); 统一错误处理 12345678// 错误处理的中间件: 有4个参数// 如果其他中间件调用了next(err) 就会来到下面的这个中间件app.use((err, req, res, next) =&gt; &#123; res.send(&#123; code: 500, message: err.message &#125;);&#125;); 中间件封装实现(以公开静态资源为例) 1234567891011121314151617181920//你会发现app.use的参数是一个函数，我们封装的函数也是需要返回一个函数的，const fs = require('fs');function pubStatic(staticUrl)&#123; return ( (req,res,next)=&gt;&#123; const filepath = staticUrl + req.path; fs.readFile(filepath,'utf8',(err,data)=&gt;&#123; if(err)&#123; throw err; &#125; res.send(data); &#125; );&#125; app.use(pubStatic('./public'));app.get('/main.css',(err,data)=&gt;&#123; &#125;); 4.MVC代码之间模块划分比较清晰，虽然它不能提高代码的执行效率，但是，它使得工程化的代码变得很清晰，利于维护。不同模块,各司其职 M-Model-模型-专门处理数据库操作 V-View-视图-专门处理视图 C-Controller-控制器-宏观调度","categories":[],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://yoursite.com/tags/模块化/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"}]},{"title":"原生ES5里的一道有趣的题目","slug":"js-es5","date":"2018-01-20T15:26:52.000Z","updated":"2018-09-21T08:05:40.183Z","comments":true,"path":"2018/01/20/js-es5/","link":"","permalink":"http://yoursite.com/2018/01/20/js-es5/","excerpt":"咋一看最后俩有点蒙了，可能是我一般不这么写的原因，很考察JS基础的一道题目，哎～，对了，你高程刷几遍了？据说这是美团的一道面试题，但是貌似也是面试中常见的题目。如果你对我的分析有别的见解，还请多多指教！","text":"咋一看最后俩有点蒙了，可能是我一般不这么写的原因，很考察JS基础的一道题目，哎～，对了，你高程刷几遍了？据说这是美团的一道面试题，但是貌似也是面试中常见的题目。如果你对我的分析有别的见解，还请多多指教！ 先看题目，假设弹出几就给函数编号为几号1234567891011121314151617181920212223242526function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;Foo.getName = function () &#123; console.log (2);&#125;;Foo.prototype.getName = function () &#123; console.log(3);&#125;;var getName = function () &#123; console.log (4);&#125;;function getName() &#123; console.log (5);&#125;// 请写出一下的输出结果Foo.getName(); //1行getName(); //2行Foo().getName(); //3行getName(); //4行new Foo.getName(); //5行new Foo().getName(); //6行new new Foo().getName();//7行 我看到的时候，答对了前五道。后两道请教了大牛才明白，看来还是得多看高程啊。 1 .预解析首先，ES5对，var,function关键字声明的变量，函数进行预解析。 本段代码预解析之后，我们得到 123456789function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;var getName = function () &#123; console.log (5);&#125;; 2.代码执行虽然预解析过程中，getName被赋值为代码块，但是，在执行 123var getName = function () &#123; console.log (4);&#125;; 的时候全局的getName函数被重新赋值给四号函数。所以在执行输出之前我们得到的是 123456789101112//Foo整体代码块function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;//此间var getName被预解析为undefined，但是之后的getName函数进行了覆盖。//getName整体代码块var getName = function () &#123; console.log (4);&#125;; 在执行输出之前，必须明确的是： 1号getName函数没有关键字this，它不是Foo的私有函数，此处的getName函数只是在修改全局的getName函数。2号函数是Foo上的方法，Foo的实例对象打点无法调用到。 开始执行 行号 分析 结果 1 Foo身上的getName方法一直都是2 2 2 全局的getName现在是4 4 3 Foo执行会修改全局的getName为1，返回值是它的调用者，这里没写，默认window，打点调用window的getName方法得到的是：1 1 4 getName();全局的getName执行 1 5 这个时候并没有先执行new调用Foo，new运算符的优先级没有点的高，而是先执行了Foo.getName。现在就是在new function () {console.log (2);} 2 6 虽然我们在new调用构造函数的时候()的作用是传参，但是在接着打点调用它原型上的方法的时候，括号的作用就是不仅仅是传参了，而是可以提高new运算符的优先级。所以这段代码，先new Foo()返回Foo的实例对象，调用实例对象身上的方法getName方法， 3 7 new new Foo().getName();相当于new Foo的实例对象的getName方法 。new function () {console.log(3);}; 3 总结：几行代码，大坑小坑不断，虽然这个时候通了，但我可能过一段时间会遗忘，给自己立一个里程碑，学习，不仅仅是要向前走，还要把所学东西分门别类的整理好。另外记录一些题外话，最近，我老能提前感知未来发生的事情，第六感准到自己都会半夜被吓醒，我究其原因：我近一年的业余时间，都在研究这个事情，要是我能把这个尽头放在前端上，又或者是股票，那我岂不是要达到很高的境界了。～加油Grace～","categories":[],"tags":[{"name":"ES5","slug":"ES5","permalink":"http://yoursite.com/tags/ES5/"},{"name":"预解析","slug":"预解析","permalink":"http://yoursite.com/tags/预解析/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"后端设定CORS，能访问数据接口，但是cookie，session无法冲破跨域限制","slug":"CORS-928-0","date":"2017-09-27T12:08:45.000Z","updated":"2018-09-29T07:47:48.045Z","comments":true,"path":"2017/09/27/CORS-928-0/","link":"","permalink":"http://yoursite.com/2017/09/27/CORS-928-0/","excerpt":"跨域导致的问题，后端开启CORS后，虽然能访问后端接口，但是会话机制没办法冲破跨域限制。做登录时候出现问题，我把前端代码放在本地Apache服务器上，他默认80端口，node提供数据，默认3000端口，此时我通过ajax访问数据，肯定会出现跨域问题。。。","text":"跨域导致的问题，后端开启CORS后，虽然能访问后端接口，但是会话机制没办法冲破跨域限制。做登录时候出现问题，我把前端代码放在本地Apache服务器上，他默认80端口，node提供数据，默认3000端口，此时我通过ajax访问数据，肯定会出现跨域问题。。。 1.配置apache反向代理1.1 配置httpd.conf打开httpd.conf 开启如下模块，行号参考，不一定准确 123LoadModule proxy_module libexec/apache2/mod_proxy.so ---132行LoadModule proxy_http_module libexec/apache2/mod_proxy_http.so ---135行Include /private/etc/apache2/extra/httpd-vhosts.conf ---517行 1.2 配置httpd-vhosts.conf打开下面的文件配置域名与反向代理，具体路径，按自己的来。 1234567891011121314151617&lt;VirtualHost *:80&gt; DocumentRoot \"/Users/grace/ymx\" ServerName www.ymx.com ServerAlias ymx.com &lt;Directory \"/Users/grace/ymx\"&gt; Options Indexes FollowSymLinks ExecCGI DirectoryIndex AllowOverride All Order allow,deny Allow from all Require all granted &lt;/Directory&gt; #开启反向代理 ProxyRequests Off #使用/api代替http://localhost:3000，不要照搬，是啥就写啥，/api也是想叫啥就叫啥 ProxyPass /api http://localhost:3000&lt;/VirtualHost&gt; 1.3 配置hosts最后在hosts文件里添加域名IP对照， 1127.0.0.1 ymx.com 可能这三个文件会有不同的修改顺序，但是别忘了重启apache，注意在使用的时候ajax里的url参数加上/api，例如：’/api/user/login’ 1.4 原理首先，跨域是浏览器作出的限制，使用ajax才会出现跨域，浏览器从一个域名的网页通过ajax去请求另一个域名下的资源时,域名、端口、协议这是三个有一种方式不同,都会被浏览器认为是跨域，既然跨域是浏览器作出的限制，那么我们可以让浏览器不去跨域，而是直接访问自己的Apache服务器，而Apache可以请求到localhost:3000端口的数据，此时跨域限制得以解决。这种方式，不需要前后端配合。 2.CORS方式(需要前后端配合，官方给的方案)其实最后发现CORS也是可以的，只是我设置的有问题，但是看起来有点麻烦。 后端需要设置响应头信息 1234//第一条设置以后，能解决数据访问问题，但是不能解决跨域问题res.header('Access-Control-Allow-Origin','www.isymx.com');//这个可以解决cookie的限制res.header('Access-Control-Allow-Credentials',true); 前端在发送ajax的时候需要配置xhrFields 12345678910$.ajax(&#123; url:'', type: 'post', xhrFields: &#123; withCredentials: true &#125;, success: function(info)&#123; //... &#125;&#125;);","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"子元素垂直水平居中的方式","slug":"centerCenter","date":"2017-06-10T11:15:02.000Z","updated":"2018-10-10T12:35:07.193Z","comments":true,"path":"2017/06/10/centerCenter/","link":"","permalink":"http://yoursite.com/2017/06/10/centerCenter/","excerpt":"说一说子元素在父元素垂直水平居中的几种方式，这里只总结我平时用的最多的，可能大牛们会有好几十种方案，我觉得适合的方案就是好方案！","text":"说一说子元素在父元素垂直水平居中的几种方式，这里只总结我平时用的最多的，可能大牛们会有好几十种方案，我觉得适合的方案就是好方案！ 0.基础结构布局123&lt;div class=\"p\"&gt; &lt;div class=\"c\"&gt;&lt;/div&gt;&lt;/div&gt; 初始css样式 12345678910.p&#123; background:red; width:100%; height:100px;&#125;.c&#123; background: yellow; width:60%; height:60%;&#125; 1.定位+transform123456789.p&#123; position:relative;&#125;.c&#123; position: absolute; left:50%; top:50%; transform: translate(-50%,-50%);&#125; css3存在兼容性问题，需要加内核前缀，但是就算加了内核前缀，低版本（8以下）还是表示，不能支持。移动端使用3d转换可以调用3d加速引擎，更快渲染，但是PC端，对3d的支持就更差一些，其实PC端没有3d加速引擎，没啥影响。 12345transform: translate(-50%,-50%);-ms-transform: translate(-50%,-50%);-moz-transform: translate(-50%,-50%);-webkit-transform: translate(-50%,-50%);-o-transform: translate(-50%,-50%); 2.单元格方式12345678.p&#123; text-align: center; display:table-cell; vertical-align: middle;&#125;.c&#123; display: inline-block;&#125; 使用该方式居中，宽高不能使用百分比，需要给定具体像素 3.flex12345.p&#123; display: flex; justify-content: center; align-items: center;&#125; flex不适用于PC端布局，但是移动端很好用 4.定位1234567891011.p&#123; position:relative;&#125;.c&#123; position: absolute; left:0px; top:0px; right:0px; bottom:0px; margin:auto;&#125; 这个看似没太大问题，而且不需要知道具体的元素尺寸，但是之前做过一个css3的宣传页动画，布局的时候需要子元素宽固定，但是拖动浏览器窗口大小，当浏览器窗口大小小于子元素宽度的时候样式乱了，此时，子元素里的内容，会相对于可视区定位。 5.定位+margin12345678910.p&#123; position:relative; &#125; .c&#123; position: absolute; left:50%; top:50%; margin-top:-25px;/*自身高度的一半*/ margin-left:-150px;/*自身宽度的一半*/ &#125; 子元素宽高必须设定为具体值，但是需要做适配的时候都不怎么使用绝对像素这种东西了。 其实，貌似哪种方案都多多少少有一定的局限，或许这才是每次做这种居中都要参考别人资料的原因吧。","categories":[],"tags":[{"name":"css布局","slug":"css布局","permalink":"http://yoursite.com/tags/css布局/"},{"name":"居中","slug":"居中","permalink":"http://yoursite.com/tags/居中/"}]},{"title":"清除浮动的四种方式","slug":"clearfix4Methods","date":"2017-06-10T05:54:48.000Z","updated":"2018-10-20T06:16:11.755Z","comments":true,"path":"2017/06/10/clearfix4Methods/","link":"","permalink":"http://yoursite.com/2017/06/10/clearfix4Methods/","excerpt":"1.W3C推荐，但是平白无故增加一个空标签，不可取，但是其他方式的原理都是这个12//在浮动元素的末尾添加一个空标签 &lt;div style=”clear:both”&gt;&lt;/div&gt;","text":"1.W3C推荐，但是平白无故增加一个空标签，不可取，但是其他方式的原理都是这个12//在浮动元素的末尾添加一个空标签 &lt;div style=”clear:both”&gt;&lt;/div&gt; 2.给浮动元素的父级添加overflow：hidden||auto||scroll12345.clearfix&#123; overflow:hidden;&#125;/*优点：代码简洁*//*缺点：内容增多时造成不会自动换行，导致内容被隐藏裁切*/ 3.after伪类清除浮动123456789 .clearfix:after &#123; content: \"\"; display: block; height: 0; clear: both;/*这个才是核心语句*/ visibility: hidden; &#125; .clearfix &#123;*zoom: 1;&#125; /* IE6、7 专有 *//*给浮动元素的直接父元素使用*/ 4.双伪元素清除浮动1234567891011.clearfix:before,.clearfix:after &#123; content:\"\"; display:table; &#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125;/*给浮动元素的直接父元素使用*/","categories":[],"tags":[{"name":"清浮动","slug":"清浮动","permalink":"http://yoursite.com/tags/清浮动/"}]},{"title":"有关JS循环","slug":"jsCircle","date":"2017-06-10T05:54:48.000Z","updated":"2018-10-25T01:44:34.098Z","comments":true,"path":"2017/06/10/jsCircle/","link":"","permalink":"http://yoursite.com/2017/06/10/jsCircle/","excerpt":"1.ECMAScript提供的方案1.1while循环123while(表达式)&#123; //执行语句&#125;","text":"1.ECMAScript提供的方案1.1while循环123while(表达式)&#123; //执行语句&#125; 1.2do…while循环123do&#123; //执行语句&#125;while(表达式) 2.数组循环2.1基本的for循环优化版本，效率最好 12345for（i = 0,len = arr.length;i&lt;len;i++）&#123; //循环arr数组arr = [1,2,3] //可以优化 console.log(arr[i]);&#125; 2.2基本的for…in循环(效率最👎)1234567891011//代码执行次数，取决于对象中有多少个属性//不仅可以遍历到对象的可枚举属性，该对象的构造函数原型上的可枚举属性也能够遍历得到var obj = &#123;a: 1, b: 2, c: 3&#125;;//我们给Object的原型加一个方法Object.prototype.fn = function()&#123; console.log('Grace');&#125;for(var key in obj)&#123; console.log(key);//a,b,c,fn console.log(obj[key]);//1,2,3,ƒ ()&#123;console.log('Grace');&#125;&#125; 数组的循环方法12345678910111213141516171819202122var arr = [1,2,3];//forEacharr.forEach(function(value,index,currentArray)&#123; &#125;);//maparr.map(function(value,index)&#123; //value是数组对应的值， //index是数组的索引&#125;);//forEacharr.forEach(function(value,index)&#123; &#125;);//数组过滤也是非常常见的，在Vue中后台管理系统，做搜索计算时常用//搜索计算的算法是可以优化的//他的返回值是一个数组var arrTmp = arr.filter((value)=&gt;&#123; if(value&gt;1)&#123; return value; &#125;&#125;); 3.jQuery提供的循环方式123$.each(要循环的arr或obj,function(index,value)&#123; //to do list&#125;)","categories":[],"tags":[{"name":"循环","slug":"循环","permalink":"http://yoursite.com/tags/循环/"}]},{"title":"说说文件上传","slug":"about-upfiles","date":"2017-06-09T07:21:56.000Z","updated":"2018-10-10T12:32:52.100Z","comments":true,"path":"2017/06/09/about-upfiles/","link":"","permalink":"http://yoursite.com/2017/06/09/about-upfiles/","excerpt":"虽说，文件上传是一件非常常见的事情，几乎每个后台管理系统都有用到，也写了好几次，但每次写，不是这有问题就是那有问题，每次都是一顿查资料，今天详细说说文件上传，也好加深一下自己的记忆。","text":"虽说，文件上传是一件非常常见的事情，几乎每个后台管理系统都有用到，也写了好几次，但每次写，不是这有问题就是那有问题，每次都是一顿查资料，今天详细说说文件上传，也好加深一下自己的记忆。 0.文件上传PHP部分可能出现的问题： 1.文件名为中文可能出现乱码，不好解决 2.避免方案：设置哈希字符串（一串十六进制数据） ​ 优点：相同文件生成的哈希值一样，如果这个文件只有1字节内容的差异，它生成的哈希值就不一样，可以利用它唯一表示一个文件。这个可以保证服务器上不存在重复的资源。减少服务器负担。 12345678910111213141516171819202122232425&lt;?php header(\"Content-Type: application/json;charset=utf-8\"); //0.接收前端的文件数据，upfile是提前约定好的 $file_info = $_FILES['upfile']; //1.获得文件后缀 $name = $file_info['name']; $arr = explode('.',$name); $ext = array_pop($arr); //2.得到hash值， $md5_str = md5_file($file_info['tmp_name']); //3.计算保存路径，文件名，一般线上是全路径，这里只是为了测试 $save_file_name = \"./upload/\" . $md5_str . \".\" . $ext; //4.移动保存 move_uploaded_file($file_info['tmp_name'],$save_file_name); //5.返回给前端是否上传成功,成功返回地址，方便前端做上传预览 echo json_encode(array( \"success\" =&gt; true, \"url\" =&gt; $save_file_name )); ?&gt; 另外，对于这门世界上最好的语言，我只是简单了解，这个只是为了测试前端的代码。就像最后我还没了解到如何判断文件是否上传成功。另外对于macOS系统的用户，别忘了开文件夹权限，否则上传不了，如图。全部改成读与写。 1.原生图片上传+预览(H5) 采用H5新增的构造函数new FormData() html部分 1234567&lt;form action=\"\" method=\"post\"&gt; &lt;h3&gt;请选择文件&lt;/h3&gt; &lt;input type=\"file\" name='upfile' id=\"file\"&gt; &lt;button type=\"submit\"&gt;上传&lt;/button&gt; &lt;!--做上传预览--&gt; &lt;img src=\"\" alt=\"\" id=\"img\"&gt;&lt;/form&gt; js部分 123456789101112131415161718192021222324252627//采用ajax上传文件，像那种需要跳转的就不写了，用户体验不好，不用var oForm = document.querySelector('form');var oFile = document.querySelector('#file');var oImg = document.querySelector('#img');//实际上并不是点击表单的submit事件上传的图片，因为要做预览，oFile.onchange = function()&#123; //只要选择文件就预览 //1.使用FormDatas收集数据(H5引入的新的构造函数) var data = new FormData(); data.append('upfile',this.files[0]); //2.发送post请求, var xhr = new XMLHttpRequest(); xhr.open('post','./upload.php'); xhr.onreadystatechange = function()&#123; if(this.readyState === 4 &amp;&amp; this.status === 200)&#123; //字符串形式的json console.log(this.responseText); var obj = JSON.parse(this.responseText); if(obj.success)&#123; //上传成功就渲染img，预览 oImg.src = obj.url; &#125; &#125; &#125; xhr.send(data);&#125; 2.jQuery提供的文件上传 原生js看起来（bushi）有（yi）点麻烦，jQuery给我们做了很多默认处理，做一些配置就好 123456789101112131415161718192021222324$('#file').on('change',function()&#123; //1.使用formDate var data = new FormData(); data.append('upfile',$(this).get(0).files[0]); //2.发送ajax请求 $.ajax(&#123; url: './upload.php', type: 'post', data: data, /////////需要添加的配置信息 cache: false, contentType: false, progressData: false, ////////配置结束 success: function(info)&#123; console.log(info); if(info.success)&#123; //上传成功就渲染img，预览 //无需转换数据格式，因为jQuery 将自动根据 HTTP 包 MIME 信息来智能判断（预期） oImg.src = info.url; &#125; &#125; &#125;);&#125;); 其实，如果是想要传多个文件，我们只需要在data里多次append就好了。其实还有很多文件上传插件😄","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"文件上传","slug":"文件上传","permalink":"http://yoursite.com/tags/文件上传/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"常用mySQL语句","slug":"mySQl","date":"2017-01-13T11:09:23.000Z","updated":"2018-10-20T06:15:11.439Z","comments":true,"path":"2017/01/13/mySQl/","link":"","permalink":"http://yoursite.com/2017/01/13/mySQl/","excerpt":"mySQL在大学里学了两遍，一个是基于运用的，上来就讲实例，一个是原理的，数据库原理概论。感觉有一整年的事件都在学这个，可见重要性，今天总结一下很常用的几个语句，加深一下印象。","text":"mySQL在大学里学了两遍，一个是基于运用的，上来就讲实例，一个是原理的，数据库原理概论。感觉有一整年的事件都在学这个，可见重要性，今天总结一下很常用的几个语句，加深一下印象。 1.数据查询语法格式 : 123456789SELECT 字段名1, 字段名2, ...... FROM 表名 [ WHERE &lt;条件表达式&gt; ] [ ORDER BY &lt;字段名&gt; [ ASC|DESC ]] [ LIMIT START, LENGTH] 1.1基本查询语法格式： 1select 字段名1, 字段名2,.... from 表名 例如: 查询管理员的id，昵称 1select admin_id,admin_nickname from tab-admin 出于性能考虑，一般不写‘*’ 1.2where（条件）查询年龄在23-28之间的管理员的所有信息 where 可以使用条件来筛选查询出的结果，例子 1select * from tab-admin where admin_age&gt;=23 and admin_age&lt;=30 或者：between…and 1select * where admin_age between 23 and 28 查询年龄不在23-28之间的管理员的所有信息 1select * where admin_age&lt;23 or admin_age&gt;28 或者：not between and 1select * where admin_age not between 23 and 28 注意：mysql的条件里没有不等于，可以用大于小于模拟不等于 1.3in（枚举）查询年龄为20、28的女性管理员信息 1select * from tab-admin where admin_gender=&apos;女&apos; and （admin_age=20 or admin_age=28） 或者 in 1select admin_id from tab-admin where admin_gender=&apos;女&apos; and admin_age in（20,28） 1.4模糊查询通配符: % : 代表任意长度(包括0)的任意字符 _ : 代表1位长度的任意字符 like: 在执行模糊查询时，必须使用like来作为匹配条件 查询邮箱地址中包含字符sina的管理员信息 1select * from tab-admin where admin_email like &apos;%sina%&apos;; 1.5order by （顺序）order by 可以对查询结果按某个字段的升降进行排序 升序 asc （默认值） ， 降序 desc 可进行排序的字段通常是 整型 英文字符串型 日期型 (中文字符串也行,但一般不用) 例如：查询所有管理员信息，按照id的降序查找 1select * from tab-admin order by admin_id desc 1.6limit限制(可用于分页)limit用来限制查询结果的起始点和长度 格式: limit var1, var2 var1: 起始点。 查询结果的索引，从0开始。 0代表第一条数据 var2: 长度 例如：查询年龄最大的3名男性管理员的信息 1select * from tab-admin where admin_gender=&apos;男&apos; order by admin_age desc limit 0,3; 1.7多表查询关键词: join on 语法格式: ​ select * from 表1 join 表2 on 链接条件 链接条件一定是 表1的某个字段 = 表2的某个字段 例子：查询学生的全部信息，系别需要使用系名来进行显示 1select tab-stu.*,tab-dept.dept_name from tab-stu join tab-dept on sdept=dept_id; 2.添加数据格式： insert into 表名(字段1，字段2，…) values(值1，值2，…); 关键点: 1) 字段和值需要一一对应，如果不对应会造成添加失败或者数据错误 2) 如果每个字段都有数据，则不需要在表名后设置字段列表 3) 带有auto_increment属性的字段可以使用null来设置，MySQL会自动填充数据 例子：向student表添加一条数据 1insert into tab-stu(sno,sname,sgender,sage) values(6,&apos;Grace&apos;,&apos;女&apos;,20); 如果每个字段都需要设置，那么可以不列出字段名，但是顺序要有保证 1insert into tab-stu values(null,&apos;Grace&apos;,&apos;女&apos;,20); 有auto_increment属性的字段，mysql会自动填充。 或者： 1insert into tab-stu set `字段名1`=value1,`字段名2`=value2...; 还是比较常用的 3.修改数据语法格式: update 表名 set 字段1=值1, 字段2=值2,... where 修改条件 修改表中的哪一条（几条）数据的 字段1=值1... 例子：将所有男性管理员的年龄都+1 1update tab-admin set admin_age=admin_age+1 where admin_gender=&apos;男&apos;; 4.删除数据语法格式: delete from 表名 where 删除条件 例子：删除id=5的管理员 1delete from tab-admin where admin_id=5; 一般是不删除数据的，都只是在做修改，比如删除会把isdelete字段改为true，表示删除数据。","categories":[],"tags":[{"name":"mySQL基本语句","slug":"mySQL基本语句","permalink":"http://yoursite.com/tags/mySQL基本语句/"}]},{"title":"JS事件委托","slug":"JSdelegate","date":"2017-01-13T05:39:14.000Z","updated":"2018-10-22T05:41:55.173Z","comments":true,"path":"2017/01/13/JSdelegate/","link":"","permalink":"http://yoursite.com/2017/01/13/JSdelegate/","excerpt":"前几天用到了原生JS的事件委托，觉得对提高dom操作效率还是重要的，闲暇之余，就来念叨一下JS事件委托。","text":"前几天用到了原生JS的事件委托，觉得对提高dom操作效率还是重要的，闲暇之余，就来念叨一下JS事件委托。 1.事件注册与移除1.1on+事件名称 这种方式几乎所有的浏览器都支持。 注册事件： 123box.onclick = function()&#123; //事件处理程序 &#125; 移除事件： 1box.onclick = null; 这种注册方式会出现覆盖，就这一个致命缺点，导致工程中不用。差不多可以直接下岗了。 1.2 addEventListener 是现代浏览器支持的新的事件注册方式，不会覆盖事件 语法：useCapture默认是false 1元素.addEventListener('click', func, useCapture); 注意：如果想要让你注册的事件能够移除，不能使用匿名函数。 移除： 1removeEventListener('click', func, useCapture); 关于事件绑定的兼容性 想必兼容性问题会是一件令人头疼的事情，但是我觉得，一个工程师的思维应该是工程性的，不会因为代码的复杂，或者兼容性而头疼，因为这是本职。 IE678不支持以上两种，但是它特立独行地提出了自己的方法attachEvent与detachEvent attachEvent: 1attachEvent('onclick', func) detachEvent的用法 1detachEvent('onclick', func) 你会清楚地看到，人家压根没有第三个参数。低版本IE是默认没有捕获的概念的 1.3jQuery的事件绑定 jQuery提供了多种事件绑定的方式，只说最常用的 on绑定 123456789101112$('#box').on('click mouseover', function () &#123; console.log('这是事件');&#125;)//多个事件的添加，对应不同方法$('#box').on(&#123; click : function () &#123; console.log('这是点击事件'); &#125;, mouseover : function () &#123; console.log('这是移入事件'); &#125;&#125;); off移除 1234567//事件移除off（）//不传入参数，移除所有事件$('#box).off()//传入事件类型名称，$('#box).off('click');//也可以指定事件以及事件对应的方法 2.事件流2.1事件冒泡 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡。 如果当事件冒泡给我们带来影响的时候，我们需要阻止事件冒泡。这个方式只阻止冒泡 现代高版本浏览器 12event = ev||window.event;event.stopPropagation(); 低版本IE 1window.event.cancleBubble(); 在Jquery中return false,既可以阻止默认事件也能阻止冒泡 2.2事件捕获 相对比较鸡肋了，IE678不支持事件捕获（基本上，我们都是用利用事件冒泡） 事件的处理将从DOM层次的根开始，而不是从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递 1234//当addEventListener第三个参数为true时，表示事件捕获arr[i].addEventListener(\"click\", function () &#123; console.log(this);&#125;,true); 2.3事件的三个阶段 1.事件的捕获-&gt;2.事件的目标阶段-&gt;3.事件的冒泡阶段 这三个阶段，我们只能干预其中一个，通常来说，我们可能会在事件冒泡上做文章，而不去管事件捕获。 3 事件委托3.1概念 事件委托就是本该自己执行的事件，让他的祖先元素代为执行。他利用了事件冒泡的机制。 3.2优点 减少了低效的DOM操作，给一个元素绑定事件，可以由多个元素触发事件，并且新添加的元素也能触发 3.2语法方式原生JS，需要判定目标元素的类型 123456el.addEventListener('click', function(e)&#123; var target = e.target || e.srcElement; if (target.className==='test') &#123; alert('this is a element named test'); &#125;&#125;) jQuery方式，第二个参数直接指定元素的类型 12345//事件委托$('#box').on('click', 'p', function (e) &#123; //绑定在#box上触发在p身上 console.log('这是内部的p标签');&#125;);","categories":[],"tags":[{"name":"事件注册","slug":"事件注册","permalink":"http://yoursite.com/tags/事件注册/"},{"name":"事件流","slug":"事件流","permalink":"http://yoursite.com/tags/事件流/"},{"name":"事件委托","slug":"事件委托","permalink":"http://yoursite.com/tags/事件委托/"}]},{"title":"搭建一个基于github和hexo的博客","slug":"hellohexo","date":"2017-01-12T14:00:09.000Z","updated":"2018-10-21T12:22:34.338Z","comments":true,"path":"2017/01/12/hellohexo/","link":"","permalink":"http://yoursite.com/2017/01/12/hellohexo/","excerpt":"这是我的第一篇博客，我只想用它来记录学习路程，之前项目遇见问题，我会查别人的博客，意识到了分享的重要性，于是开始将我的写作放到博客上来。如果有不对的地方，希望大家多多批评指正。","text":"这是我的第一篇博客，我只想用它来记录学习路程，之前项目遇见问题，我会查别人的博客，意识到了分享的重要性，于是开始将我的写作放到博客上来。如果有不对的地方，希望大家多多批评指正。 1.首先你需要安装git和node环境，假如你安装了node，npm是默认安装的。 2.安装hexo你可以先检查一下是否安装了hexo。 1$ hexo -v 如果没有输出版本号，接着安装 1$ npm i hexo -g 3.创建git仓库登陆你的git账号，建立一个仓库，这个仓库名字必须是 用户名.github.io,并且一个github账号只能注册一个博客地址。本文所有的用户名都代表你的github用户名 4.创建本地博客文件夹在你喜欢的任何地方创建一个文件夹，用来创建本地博客，打开终端，cd到这个文件夹，初始化hexo 1$ hexo init 这个过程有可能会报安装依赖失败的error，我在win10上没有遇见，在mac上遇见了，此时安装依赖，即执行 1$ npm install 初始化完成之后，你就可以在本地预览你的博客了，启动服务器，s是server的意思，即执行 1$ hexo s 在本地浏览器地址栏输入http://localhost:4000/可以本地预览你的作品。不过可能看起来似乎有点low。但后期是可以更改主题的。 5.将本地博客推送至远程git仓库找到本地博客文件夹，根目录的_config.yml，拉到最后修改一个配置，注意冒号后有一个空格，每个键名前是两个空格。末尾不要留下空格 1234deploy: type: git branch: master repository: https://github.com/用户名/用户名.github.io.git 开始准备上传 1$ hexo g 上传 1$ hexo d 我在此处出错了，执行下面命令 1$ npm i hexo-deployer-git 下载完依赖之后再次执行 1$ hexo d 上传成功，在浏览器上访问你的用户名.github.io,就可以访问了 6.如何增加博客？在你博客文件夹下运行终端，创建一篇文章 1$ hexo new 文章名字 找到根目录下的source/_posts文件夹，你刚创建的博客md文档就出现了，你就可以在这里编写你的博客了，写好之后你预览了没问题就可以上传 12$ hexo g $ hexo d 7.修改主题如果你不喜欢那种原生的田园风格，可以尝试更换主题，我采用的主题是https://github.com/litten/hexo-theme-yilia,具体配置方案上面有文档，需要注意的是头像的图片地址放在yilia/source下路径，具体你想放在哪里写在yilia/_config.yml配置文件里就行啦！另外这是主题的中文文档地址http://moxfive.coding.me/yelee/ 8.绑定域名 这个要看你想不想绑定了，我是之前就有购买域名，所以用在了这里 1.如果你的域名需要实名认证，请提前认证，大概需要两三天吧。 2.获取github的IP地址：终端 ping 用户名.github.io记录下IP地址，这个IP是要和你的域名绑定的。 3.我是在阿里云购买的域名，登录&gt;控制台&gt;域名&gt;解析&gt;添加记录 CNAME记录值是你的用户名.github.io A对应的记录值是你刚才ping到的IP地址 4.根目录下的&gt;_config.yml修改skip_render: CNAME 5.在你的本地的文件夹根目录&gt;source下创建一个没有后缀的，名为CNAME的文件，里面写上你的域名，注意写错了报404，之后hexo gand hexo d 之后大功告成。试试用你的域名访问你的博客吧！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]