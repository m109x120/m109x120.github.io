[{"title":"ES6","slug":"ES6","date":"2018-09-17T11:02:23.000Z","updated":"2018-09-20T09:40:00.240Z","comments":true,"path":"2018/09/17/ES6/","link":"","permalink":"http://yoursite.com/2018/09/17/ES6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"react基本语法特征","slug":"react-basic-928-0","date":"2018-03-28T03:51:13.000Z","updated":"2018-10-20T05:41:12.023Z","comments":true,"path":"2018/03/28/react-basic-928-0/","link":"","permalink":"http://yoursite.com/2018/03/28/react-basic-928-0/","excerpt":"总结一下基本的react语法，以及特有的jsx，组件传值，包括子组件修改父组件的数据，兄弟组件的通信，实际上也就是单向数据流的概念。","text":"总结一下基本的react语法，以及特有的jsx，组件传值，包括子组件修改父组件的数据，兄弟组件的通信，实际上也就是单向数据流的概念。 1.react的优点react本身只是一个视图层的框架，它抛弃了传统的继承模式，采用组件化的方式开发，采用了jsx表达式，jsx只有在react里才有的，用来处理数据和DOM的关系，不需要我们操作DOM，我们所关心的是数据，dom也是由数据在驱动，不同于art-template等之类的模版字符串，它采用虚拟DOM的方式减少低效的DOM操作。 2.jsx基础语法 基本用法，样式用法，变量的使用，逻辑的处理 1234567891011121314151617181920212223242526272829//导入react，react-domimport React from 'react';import ReactDOM from 'react-dom';let obj = &#123; name: 'Grace', flag: true&#125;;let arr = ['Apple','ml','oppo'];let style = &#123; color:'r'+'ed', fontSize: 30+20+'px' //虽然直接加样式的方式不常用，但它支持逻辑，&#125;;let jsx = ( &lt;div style=&#123;style&#125; className='jsx'&gt; &#123;/*条件判断与变量的使用*/&#125; &#123; obj.flag ? &lt;p&gt;I am &#123;obj.name&#125;&lt;/p&gt; : &lt;p&gt;I am not &#123;obj.name&#125;&lt;/p&gt; &#125; &#123;/*数组循环*/&#125; &#123; arr.map((name,index) =&gt; &lt;p key=&#123;index&#125;&gt;第&#123;index&#125;号商品:&#123;name&#125;&lt;/p&gt;) &#125; &lt;/div&gt;);ReactDOM.render( jsx, document.querySelector('#app')); 3.react组件（ES6）本段代码包含，数据传递，修改数据，以及事件绑定 123456789101112131415161718192021222324252627282930313233343536373839class Compontent extends React.Component&#123; constructor(props)&#123; //父组件向子组件传递数据 super(props); this.state = &#123; age: 18 &#125; &#125; handelClick()&#123; //修改自身的数据 this.setState(&#123; age : this.state.age+1 &#125;); &#125; handelChange(e)&#123; this.setState(&#123; age : e.target.value &#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;I am &#123;this.props.name&#125;,我今年 &#123;this.state.age&#125; 岁了&lt;/h1&gt; &#123;/*在事件绑定上使用了箭头函数，这是利用了，ES6箭头函数自身没有this的概念，它继承自父类 的 this，正好使用这种方式，我们无需重新绑定this*/&#125; &lt;button onClick=&#123;(e)=&gt;&#123;this.handelClick(e)&#125;&#125;&gt;加一岁&lt;/button&gt; &lt;input type=\"text\" onChange=&#123;(e)=&gt;&#123;this.handelChange(e)&#125;&#125;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( //只能是一层 &lt;div&gt; &lt;Compontent name='Grace'/&gt; &lt;Compontent name='Jack'/&gt; &lt;/div&gt;, document.querySelector('#app')); 4. 组件之间的关系容器式与单纯组件写法123456789101112131415161718192021222324252627282930313233343536class Compontent extends React.Component&#123; render()&#123; return ( &lt;h2&gt;Compontent&lt;/h2&gt; ) &#125;&#125;class Title extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;h1&gt;&#123;this.props.children&#125;&lt;/h1&gt; ) &#125;&#125;class App extends React.Component&#123; render()&#123; return( &lt;div className=''&gt; &#123;/*容器式组件*/&#125; &lt;Title&gt; &lt;h2&gt;App h2&lt;/h2&gt; &lt;/Title&gt; &lt;hr/&gt; &#123;/*单纯组件*/&#125; &lt;Compontent/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;App /&gt;, document.querySelector('#app')); 我们发现，父组件向子组件传值很方便，通过props，但是子组件向父组件传值如何实现？兄弟组件呢？ 5. 组件传值5.1父组件向子组件传值：props5.2子组件修改父组件的值其实，我们没办法在子组件里修改父组件的值，props传来的数据是只读的，但是我们可以告诉父组件我想让你帮我把某个数据改掉，这个我们可以通过回调来处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 父子组件的数据通信// 子组件想要改变父组件的样式class Children extends React.Component&#123; constructor(props)&#123; super(props); &#125; handelClick(e)&#123; // 我们可以通过props得到父组件传来的fontColor // console.log(this.props.bgColor); // 我们无法直接修改props，因为它是只读数据 // 我们可以采用回调的形式，来告诉父组件，我想要修改某个值，而实际上还是虽然是在子组件里面点击了按 //钮，但是触发修改数据的是父组件，因为单向数据流，数据在父组件身上呢。 this.props.colorChange('red'); &#125; render()&#123; return ( &#123;/*第一层大括号是表达式，第二层大括号是json结构*/&#125; &lt;div style=&#123;&#123;background:this.props.bgColor&#125;&#125;&gt; &lt;button onClick=&#123;(e)=&gt;&#123;this.handelClick(e)&#125;&#125;&gt;改变父组件的bgColor颜色 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class Father extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123; bgColor : 'green' &#125; &#125; onBgColorChange(color)&#123; // color值是从子组件传来的，只要有值传过来，就能触发这个事件 this.setState(&#123; bgColor: color &#125;) &#125; render()&#123; return( &lt;div style=&#123;&#123;background:this.state.bgColor&#125;&#125;&gt; &lt;h1&gt;父组件背景色：&#123;this.state.bgColor&#125;&lt;/h1&gt; &#123;/* 调用子组件，并传值进去 */&#125; &lt;Children colorChange=&#123;(color)=&gt;&#123;this.onBgColorChange(color)&#125;&#125;/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Father/&gt;, document.querySelector('#app')); 5.3兄弟组件传值用到了变量提升，把需要更改的值，以及更改操作都放在父组件里。因为单项数据流的原因，当父组件的值发生改变，会向下传递到子组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Children1 extends React.Component&#123; // 接收父组件传值 constructor(props)&#123; super(props); &#125; handelClick()&#123; this.props.changeChild2Color('yellow'); &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;child1:&lt;/h2&gt; &lt;button onClick=&#123;(e)=&gt;&#123;this.handelClick(e)&#125;&#125;&gt;改变child2的背景颜色&lt;/button&gt; &lt;hr/&gt; &lt;/div&gt; ) &#125;&#125;class Children2 extends React.Component&#123; // 接收组件传来的值 constructor(props)&#123; super(props); &#125; render()&#123; return ( &lt;div style=&#123;&#123;color:this.props.bgColor&#125;&#125;&gt; &lt;h2&gt;child2: &#123;this.props.bgColor&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;class Father extends React.Component&#123; constructor(props)&#123; super(props); // 把应该在child2里的数据保存在父组件中，叫状态提升 this.state = &#123; child2BgColor: 'red' &#125; &#125; changeColor(color)&#123; // console.log(color); yellow传过来了 this.setState(&#123; child2BgColor: color &#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;Children1 changeChild2Color=&#123;(color)=&gt;&#123;this.changeColor(color)&#125;&#125;/&gt; &lt;Children2 bgColor=&#123;this.state.child2BgColor&#125;/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Father/&gt;, document.querySelector('#app')); 6.react声明周期生命周期是一个组件从生到死的整个过程 6.1Mounting挂载(渲染)阶段最先出现的是： 1constructor()&#123;&#125; 组件将要渲染： 1componentWillMount()&#123;&#125; 组件渲染： 1render()&#123;&#125; 组件渲染完成： 1componentDidMount()&#123;&#125; 简单测试一下 12345678910111213141516171819class Test extends React.Component&#123; constructor(props)&#123; super(props); console.log('Mount: constructor'); &#125; componentWillMount()&#123; console.log('Mount: componentWillMount'); &#125; componentDidMount()&#123; console.log('Mount: componentDidMount'); &#125; render()&#123; console.log('render'); return ( &lt;h1&gt;hahah&lt;/h1&gt; ); &#125;&#125; 执行结果：Mount: constructor-&gt;Mount: componentWillMount-&gt;render-&gt;Mount: componentDidMount 6.2 Updating运行时阶段(组件更新引起的变化)自更新是没有钩子的，只有是父组件修改数据才能触发 将要接收父组件传来的props 1componentWillReceiveProps()&#123;&#125; 子组件是否需要更新 1234shouldComponentUpdata()&#123; //这个方法返回false后面的都不再执行 return true;&#125; 子组件将要更新 1compontentWillUpdata()&#123;&#125; 子组件更新 1render()&#123;&#125; 子组件更新完成 1compontentDidUpdate()&#123;&#125; 同样测试一下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Test extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; content: 'haha' &#125; console.log('Mount: constructor'); &#125; componentWillMount()&#123; console.log('Mount: compontentWillMount'); &#125; handelClick()&#123; this.props.changeContent('Grace'); &#125; render()&#123; console.log('render'); return ( &lt;h1 onClick=&#123;()=&gt;&#123;this.handelClick()&#125;&#125;&gt;&#123;this.props.content&#125;&lt;/h1&gt; ); &#125; componentDidMount()&#123; console.log('Mount: compontentDidMount'); &#125; componentWillReceiveProps()&#123; console.log('Updating: componentWillReceiveProps'); &#125; shouldComponentUpdate()&#123; console.log('Updating: shouldComponentUpdate'); return true; &#125; componentDidUpdate()&#123; console.log('Updating: componentDidUpdate'); &#125;&#125;class F extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; content: 'haha' &#125; &#125; setContent(context)&#123; this.setState(&#123; content: context &#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;Test content=&#123;this.state.content&#125; changeContent=&#123;(context)=&gt;&#123;this.setContent(context)&#125;&#125;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;F/&gt;, document.querySelector('#app')); 执行结果：Updating: componentWillReceiveProps-&gt;Updating: shouldComponentUpdate-&gt;render-&gt;Updating: componentDidUpdate 6.3Unmounting卸载阶段组件将要销毁 123compontentWillUnmount()&#123; //如果做了定时器，在销毁前要清定时器，以减少性能消耗&#125; 6.4Error Handing错误处理(react16独有)这种错误并不是逻辑错误，只处理在render时候的错误 还有其他非常重点的东西，下次总结路由：React-Router ，很有意思，牵扯的历史的东西也是很多。react生态系统很庞大，有一定的学习成本","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"jsx","slug":"jsx","permalink":"http://yoursite.com/tags/jsx/"},{"name":"react组件传值","slug":"react组件传值","permalink":"http://yoursite.com/tags/react组件传值/"},{"name":"生命周期","slug":"生命周期","permalink":"http://yoursite.com/tags/生命周期/"}]},{"title":"react开发打包环境的搭建","slug":"reactProductEnvironment","date":"2018-03-18T14:30:07.000Z","updated":"2018-10-20T05:31:17.030Z","comments":true,"path":"2018/03/18/reactProductEnvironment/","link":"","permalink":"http://yoursite.com/2018/03/18/reactProductEnvironment/","excerpt":"总结一下搭建react开发环境基本过程，以及在搭建过程中遇见的大坑，小坑。。。","text":"总结一下搭建react开发环境基本过程，以及在搭建过程中遇见的大坑，小坑。。。 1.git的安装和配置 git安装(想必都会，只总结mac系统遇到的问题) 官网下载git的.dmg安装包，双击打开，双击.pkg的安装包，😯，报错了…打不开身份不明开发者。这是由于mac安全限制外部下载的软件。 解决方案：打开系统偏好设置&gt;安全与隐私&gt;通用：提示已阻止打开“git-…pkg”,因为来自身份不明的开发者。倔强地选择仍要打开。 接着傻瓜式下一步…ok。 检测是不是安装成功了(成功输出git的版本号) 1$ git --version 配置.gitconfig(它是一个用户目录下的隐藏文件，终端ls看不见隐藏文件，ls -all可以看见) 1$ vim ~/.gitconfig 进来之后，用小写字母i进入编辑模式，user不配置首次提交的时候也会让你输入，这里的email是注册git的时候使用的邮箱。alias是git命令简写，我只配了一些常用的。⚠️等号两边不要加空格呀！ 123456789101112[user] name=Grace email=***@163.com[alias] co=checkout ci=commit st=status pl=pull ps=push dt=difftool ca=commit -am b=branch 写好之后按ESC推出编辑模式，输入:wq+回车保存并退出.gitconfig的编辑模式，我们还可以查看刚才的配置信息。 1$ cat ~/.gitconfig 2.项目的建立 获取ssh密钥邮箱是刚才配置的那个，执行完这条命令之后，一直回车到执行完 1$ ssh-keygen -t rsa -C '***@163.com' 此时会在用户目录下生成一个.ssh的文件夹，cd到这个文件夹,ls-all查看所有文件，那个id_rsa.pub就是存放公钥的文件 1$ cat id_rsa.pub 查看公钥内容，复制下来。 打开gitee.com，码云在国内，速度快。 创建一个项目&gt;管理&gt;部署公钥管理&gt;公钥管理&gt;添加个人共钥，把刚才在终端复制的公钥贴进来。 then可以把远程项目代码clone到本地了，克隆下载 &gt; 选择ssh，因为刚才已经添加过个人公钥了。 在用户目录下新建一个空文件夹用于存放项目，cd 到这个文件夹，git clone～～～，远程代码成功拉到本地。现在远程和本地已经建立起来了。 我们还需要添加一个.gitignore文件，忽略我们不需要push到仓库的文件 1$ vim .gitignore 输入i进行编辑，上传的是源码。 1234.DS_Storenode_modulesdist*.log ESC :wq+回车 保存成功，push到远程 3.安装node.js和yarnNode.js安装过程非常简单，记得指定版本。（node的安装官网很详细） 为什么不用node自带的npm? 因为yarn安装速度快，这种快并不仅仅是服务器快，而且并行下载，还有牛掰的缓存机制，之前装过的包是走缓存的，可以断网使用，达到秒装效果。yarn的版本锁定机制是严格的，而npm是按照版本范围来的。 我们可以使用npm来安装yarn， 1$ npm i yarn -g yarn与npm的语法对比 Yarn Npm yarn init npm init yarn npm install yarn global add xxx@x.x.x npm install xxx@x.x.x -g yarn add xxx@x.x.x npm install xxx@x.x.x yarn add xxx@x.x.x –dev npm install xxx@x.x.x -dev yarn remove xxx npm uninstall xxx (-dev) yarn run xxx npm run xxx 4.初始化项目上一步安装完了node和yarn，cd到项目文件夹，初始化yarn，提示出的信息我们可以不填写，走默认的。 1$ yarn init git st-&gt;git add .-&gt;git ca &quot;yarn init&quot;-&gt;git ps将文件推送到远程仓库 5.webpack的安装和配置5.1.webpack概念前端资源打包工具，html，css，脚本，字体等资源都会被看作一个模块，都会被打包到js里。 5.2.多版本共存的解决方案全局只能安装一个啦，俩项目又不想使用同一个版本怎么搞啦！为了避免冲突，我们不可能在全局安装两个版本的webpack，node_modules&gt;.bin下面有一个可执行的webpack文件，使用这种方式，可以避免影响。webpack的安装。cd到项目根目录，为了避免冲突，这里所用到的所有工具，我都安装在项目里，不在全局安装。 1$ yarn add webpack@3.10.0 --dev 5.3.entry在项目根目录下新建一个webpack.config.js，配置信息重要看官方文档 12345678const path = require('path');module.exports = &#123; entry: './src/app.js', //这是需要打包的文件路径，配置react的时候会改为jsx后缀 output: &#123; path: path.resolve(__dirname,'./dist'), //打包到目标文件夹 filename: 'app.js' //打包成功后的文件命名方式 &#125;&#125; 可以在src&gt;app.js随便写点东西，测试一下webpack是不是打包成功了。(下面的命令貌似有点长，最后再解决这个问题) 1$ node_modules/.bin/webpack 成功打包js～ 5.4.html安装htmlwebpackplugin插件，最好是指定版本（另外你安装了啥都在package.json文件里，这是yarn为我们自动生成的） 1$ yarn add html-webpack-plugin@2.30.1 --dev 配置htmlwebpackplugin插件 123456789101112//在webpack.config.js里引入htmlwebpackplugin插件const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; . . . , //接着刚才的入口出口 写htmlwebpackplugin的配置 plugin: [ new HtmlWebpackPlugin() ]&#125; 打包一次试试看看什么效果，打包方式同entry里的方法。dist文件夹下多一个index.html文件，它默认引入了dist&gt;app.js文件，但是看起来好像跟我们想要的不太一样，有些标签没加，比如视口大小没有定义等等。我们可以指定模版,在src文件夹下新建一个index.html把这个文件作为模版。 123456plugin: [ new HtmlWebpackPlugin(&#123; //引用模版文件,这个文件默认的输出就是dist&gt;index.html template: './src/index.html' &#125;)] 5.5.脚本5.5.1.ES6语法在项目根目录下安装babel相关的插件，用于打包ES6的语法 1$ yarn add babel-core@6.26.0 babel-preset-env@1.6.1 babel-loader@7.1.2 --dev 配置webpack.config.js 12345678910111213141516171819202122232425262728module.exports = &#123; entry: './src/app.js', //使用react之后，文件后缀是jsx,与入口文件后缀保持一致 output: &#123; path: path.resolve(__dirname,'./dist'), filename: 'app.js' &#125;, //babel的配置开始 module: &#123; rules: [ &#123; test:/\\.js$/, //使用react之后文件后缀改为了jsx exclude: /(node_modules)/, //对参数不做处理 use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ] &#125;, //babel配置结束 . . .&#125; 之后在src&gt;app.js里写入ES6语法的代码，之后打包，我们会发现dist&gt;app.js里面已经被转为ES5的语法了。 5.5.2 react语法处理（相对好搞的部分）项目根目录装插件 1$ yarn add babel-preset-react@6.24.1 --dev 配置webpack.config.js，在刚才配置babel的preset环境中添加react,把js文件后缀改为jsx就ok了。 1presets: ['env','react'] 安装react，这是我们代码里要用的，不是生产工具 1$ yarn add react@16.2.0 react-dom@16.2.0 在src&gt;app.jsx下书写react代码，打包成功啦～,注意这个时候就webpack.config.js里的配置应该改为jsx后缀名了。 5.6.样式需要配置style-loader，css-loader ，sass-loader 5.6.1 安装style-loader和css-loader1$ yarn add style-loader@0.19.1 css-loader@0.28.8 --dev 修改配置文件，在rules中的react语法后接着配置 123456789//style-loader与css-loader的配置信息&#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ]&#125;//style-loader与css-loader的配置信息结束 在src&gt;新建index.css,写点样式，在src&gt;app.jsx中引入css 1import './index.css' 打包成功，css被打包到dist&gt;app.js中，我测试的dist下的文件，样式生效～，但是以这种方式打包出来的样式要等到所有js加载完成之后css在执行，有可能会出现网页裸奔效果，所以，我们应该想办法把它单独放在一个css文件里，然后 打包后 dist&gt;app.js已经引入～ 安装extract-text-webpack-plugin 1$ yarn add extract-text-webpack-plugin@3.0.2 --dev 配置webpack.config.js，把刚才配置的css里的use改为下面的代码,另外需要引入，new插件 123456789101112131415161718192021222324252627282930//extract-text-webpack-plugin 引入const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; . . . module: &#123; rules: [ //react语法的处理 . . . //css文件的处理 &#123; test: /\\.css$/, //extract-text-webpack-plugin use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) //extract-text-webpack-plugin &#125; ] &#125;, plugins: [ //extract-text-webpack-plugin 生成文件的位置 new ExtractTextPlugin('index.css') //extract-text-webpack-plugin ]&#125; 打包成功，～，css自动被引入了， 5.6.2处理sass安装sass-loader 1$ yarn add sass-loader@6.0.6 --dev 在webpack.config.js的module里的css文件的处理后，添加 12345678//sass文件的处理&#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: ['css-loader','sass-loader'] &#125;)&#125; 在src下面新建一个scss文件，在app.jsx中引入这个文件，打包成功，成功，，，哎？尼玛，报错了。。。而且还是scss文件的语法错误，尼玛三行测试代码有错，不科学呐～ 一顿找。。 因为，sass-loader依赖node-sass和webpack,赶紧安装一下，此包安装的时间可真久， 1$ yarn add node-sass@4.7.2 --dev 这回打包成功了～ 5.7图片和静态文件的处理 这或许有点麻烦了 5.7.1 图片的配置安装url-loader,url-loader依赖file-loader 1$ yarn add file-loader@1.1.6 url-loader@0.6.2 --dev 在刚才的webpack.config.js中的sass文件处理后接着写 12345678910111213//图片的配置&#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, //小于这个大小的图片资源直接转成base64 name: 'resource/[name].[ext]' //文件打包后的位置 &#125; &#125; ]&#125; 可以试试一张图片是不是被打包成功了， 5.7.2 配置字体（font-Awesome）安装一个font-Awesome 1$ yarn add font-awesome 配置webpack.config.js，接着图片处理写 12345678910111213//字体的处理&#123; test: /\\.(eot|svg|ttf|woff|woff2|otf)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, name: 'resource/[name].[ext]' //文件打包后的位置 &#125; &#125; ]&#125; 打包成功，dist目录多了很多文件。 5.7.3 通用模块提取的插件在webpack.config.js的plugin中 123456789101112131415const webpack = require('webpack'); plugins: [ //处理html文件 . . . //独立css文件 new ExtractTextPlugin('css/[name].css'), //提出公共模块的插件 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'common', filename: 'js/base.js' //通用的文件被打包到这个文件里 &#125;)]//可以规划一下打包文件路径 规划完路径之后会找不到静态资源是怎么回事呢？ 5.7.4 webpack-dev-server 自动刷新安装webpack-dev-server 1$ yarn add webpack-dev-server@2.9.7 --dev 在webpack .config.js的最后，在出口里，定义一个公共路径，不然后字体文件找不到路径，因为服务器是从根目录开始找的 12345678output: &#123; path: path.resolve(__dirname,'dist'), publicPath: '/dist/', filename: 'js/app.js'&#125;,devServer: &#123; port: 8086 //默认的8080端口可能会被占用，所以修改&#125; 启动服务： 1$ node_modules/.bin/webpack-dev-server 之后每改动一次文件，浏览器是自动刷新的。 最后一步，在package.json中配置一些脚本，只是有些命令太长了， 1234\"scripts\": &#123; \"dev\": \"node_modules/.bin/webpack-dev-server\", \"dist\": \"node_modules/.bin/webpack -p\" //线上环境的打包&#125;, yarn run dev就可以开启本地服务，会默认打包的， 到此，一个简单的react开发环境搭完成，但是，，这并不是最终的，这只是最简单的配置，在开发过程中还会进行别的配置。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"原生ES5里的一道有趣的题目","slug":"js-es5","date":"2018-01-20T15:26:52.000Z","updated":"2018-09-21T08:05:40.183Z","comments":true,"path":"2018/01/20/js-es5/","link":"","permalink":"http://yoursite.com/2018/01/20/js-es5/","excerpt":"咋一看最后俩有点蒙了，可能是我一般不这么写的原因，很考察JS基础的一道题目，哎～，对了，你高程刷几遍了？据说这是美团的一道面试题，但是貌似也是面试中常见的题目。如果你对我的分析有别的见解，还请多多指教！","text":"咋一看最后俩有点蒙了，可能是我一般不这么写的原因，很考察JS基础的一道题目，哎～，对了，你高程刷几遍了？据说这是美团的一道面试题，但是貌似也是面试中常见的题目。如果你对我的分析有别的见解，还请多多指教！ 先看题目，假设弹出几就给函数编号为几号1234567891011121314151617181920212223242526function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;Foo.getName = function () &#123; console.log (2);&#125;;Foo.prototype.getName = function () &#123; console.log(3);&#125;;var getName = function () &#123; console.log (4);&#125;;function getName() &#123; console.log (5);&#125;// 请写出一下的输出结果Foo.getName(); //1行getName(); //2行Foo().getName(); //3行getName(); //4行new Foo.getName(); //5行new Foo().getName(); //6行new new Foo().getName();//7行 我看到的时候，答对了前五道。后两道请教了大牛才明白，看来还是得多看高程啊。 1 .预解析首先，ES5对，var,function关键字声明的变量，函数进行预解析。 本段代码预解析之后，我们得到 123456789function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;var getName = function () &#123; console.log (5);&#125;; 2.代码执行虽然预解析过程中，getName被赋值为代码块，但是，在执行 123var getName = function () &#123; console.log (4);&#125;; 的时候全局的getName函数被重新赋值给四号函数。所以在执行输出之前我们得到的是 123456789101112//Foo整体代码块function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;//此间var getName被预解析为undefined，但是之后的getName函数进行了覆盖。//getName整体代码块var getName = function () &#123; console.log (4);&#125;; 在执行输出之前，必须明确的是： 1号getName函数没有关键字this，它不是Foo的私有函数，此处的getName函数只是在修改全局的getName函数。2号函数是Foo上的方法，Foo的实例对象打点无法调用到。 开始执行 行号 分析 结果 1 Foo身上的getName方法一直都是2 2 2 全局的getName现在是4 4 3 Foo执行会修改全局的getName为1，返回值是它的调用者，这里没写，默认window，打点调用window的getName方法得到的是：1 1 4 getName();全局的getName执行 1 5 这个时候并没有先执行new调用Foo，new运算符的优先级没有点的高，而是先执行了Foo.getName。现在就是在new function () {console.log (2);} 2 6 虽然我们在new调用构造函数的时候()的作用是传参，但是在接着打点调用它原型上的方法的时候，括号的作用就是不仅仅是传参了，而是可以提高new运算符的优先级。所以这段代码，先new Foo()返回Foo的实例对象，调用实例对象身上的方法getName方法， 3 7 new new Foo().getName();相当于new Foo的实例对象的getName方法 。new function () {console.log(3);}; 3 总结：几行代码，大坑小坑不断，虽然这个时候通了，但我可能过一段时间会遗忘，给自己立一个里程碑，学习，不仅仅是要向前走，还要把所学东西分门别类的整理好。另外记录一些题外话，最近，我老能提前感知未来发生的事情，第六感准到自己都会半夜被吓醒，我究其原因：我近一年的业余时间，都在研究这个事情，要是我能把这个尽头放在前端上，又或者是股票，那我岂不是要达到很高的境界了。～加油Grace～","categories":[],"tags":[{"name":"ES5","slug":"ES5","permalink":"http://yoursite.com/tags/ES5/"},{"name":"预解析","slug":"预解析","permalink":"http://yoursite.com/tags/预解析/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"后端设定CORS，能访问数据接口，但是cookie，session无法冲破跨域限制","slug":"CORS-928-0","date":"2017-09-27T12:08:45.000Z","updated":"2018-09-29T07:47:48.045Z","comments":true,"path":"2017/09/27/CORS-928-0/","link":"","permalink":"http://yoursite.com/2017/09/27/CORS-928-0/","excerpt":"跨域导致的问题，后端开启CORS后，虽然能访问后端接口，但是会话机制没办法冲破跨域限制。做登录时候出现问题，我把前端代码放在本地Apache服务器上，他默认80端口，node提供数据，默认3000端口，此时我通过ajax访问数据，肯定会出现跨域问题。。。","text":"跨域导致的问题，后端开启CORS后，虽然能访问后端接口，但是会话机制没办法冲破跨域限制。做登录时候出现问题，我把前端代码放在本地Apache服务器上，他默认80端口，node提供数据，默认3000端口，此时我通过ajax访问数据，肯定会出现跨域问题。。。 1.配置apache反向代理1.1 配置httpd.conf打开httpd.conf 开启如下模块，行号参考，不一定准确 123LoadModule proxy_module libexec/apache2/mod_proxy.so ---132行LoadModule proxy_http_module libexec/apache2/mod_proxy_http.so ---135行Include /private/etc/apache2/extra/httpd-vhosts.conf ---517行 1.2 配置httpd-vhosts.conf打开下面的文件配置域名与反向代理，具体路径，按自己的来。 1234567891011121314151617&lt;VirtualHost *:80&gt; DocumentRoot \"/Users/grace/ymx\" ServerName www.ymx.com ServerAlias ymx.com &lt;Directory \"/Users/grace/ymx\"&gt; Options Indexes FollowSymLinks ExecCGI DirectoryIndex AllowOverride All Order allow,deny Allow from all Require all granted &lt;/Directory&gt; #开启反向代理 ProxyRequests Off #使用/api代替http://localhost:3000，不要照搬，是啥就写啥，/api也是想叫啥就叫啥 ProxyPass /api http://localhost:3000&lt;/VirtualHost&gt; 1.3 配置hosts最后在hosts文件里添加域名IP对照， 1127.0.0.1 ymx.com 可能这三个文件会有不同的修改顺序，但是别忘了重启apache，注意在使用的时候ajax里的url参数加上/api，例如：’/api/user/login’ 1.4 原理首先，跨域是浏览器作出的限制，使用ajax才会出现跨域，浏览器从一个域名的网页通过ajax去请求另一个域名下的资源时,域名、端口、协议这是三个有一种方式不同,都会被浏览器认为是跨域，既然跨域是浏览器作出的限制，那么我们可以让浏览器不去跨域，而是直接访问自己的Apache服务器，而Apache可以请求到localhost:3000端口的数据，此时跨域限制得以解决。这种方式，不需要前后端配合。 2.CORS方式(需要前后端配合，官方给的方案)其实最后发现CORS也是可以的，只是我设置的有问题，但是看起来有点麻烦。 后端需要设置响应头信息 1234//第一条设置以后，能解决数据访问问题，但是不能解决跨域问题res.header('Access-Control-Allow-Origin','www.isymx.com');//这个可以解决cookie的限制res.header('Access-Control-Allow-Credentials',true); 前端在发送ajax的时候需要配置xhrFields 12345678910$.ajax(&#123; url:'', type: 'post', xhrFields: &#123; withCredentials: true &#125;, success: function(info)&#123; //... &#125;&#125;);","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"子元素垂直水平居中的方式","slug":"centerCenter","date":"2017-06-10T11:15:02.000Z","updated":"2018-10-10T12:35:07.193Z","comments":true,"path":"2017/06/10/centerCenter/","link":"","permalink":"http://yoursite.com/2017/06/10/centerCenter/","excerpt":"说一说子元素在父元素垂直水平居中的几种方式，这里只总结我平时用的最多的，可能大牛们会有好几十种方案，我觉得适合的方案就是好方案！","text":"说一说子元素在父元素垂直水平居中的几种方式，这里只总结我平时用的最多的，可能大牛们会有好几十种方案，我觉得适合的方案就是好方案！ 0.基础结构布局123&lt;div class=\"p\"&gt; &lt;div class=\"c\"&gt;&lt;/div&gt;&lt;/div&gt; 初始css样式 12345678910.p&#123; background:red; width:100%; height:100px;&#125;.c&#123; background: yellow; width:60%; height:60%;&#125; 1.定位+transform123456789.p&#123; position:relative;&#125;.c&#123; position: absolute; left:50%; top:50%; transform: translate(-50%,-50%);&#125; css3存在兼容性问题，需要加内核前缀，但是就算加了内核前缀，低版本（8以下）还是表示，不能支持。移动端使用3d转换可以调用3d加速引擎，更快渲染，但是PC端，对3d的支持就更差一些，其实PC端没有3d加速引擎，没啥影响。 12345transform: translate(-50%,-50%);-ms-transform: translate(-50%,-50%);-moz-transform: translate(-50%,-50%);-webkit-transform: translate(-50%,-50%);-o-transform: translate(-50%,-50%); 2.单元格方式12345678.p&#123; text-align: center; display:table-cell; vertical-align: middle;&#125;.c&#123; display: inline-block;&#125; 使用该方式居中，宽高不能使用百分比，需要给定具体像素 3.flex12345.p&#123; display: flex; justify-content: center; align-items: center;&#125; flex不适用于PC端布局，但是移动端很好用 4.定位1234567891011.p&#123; position:relative;&#125;.c&#123; position: absolute; left:0px; top:0px; right:0px; bottom:0px; margin:auto;&#125; 这个看似没太大问题，而且不需要知道具体的元素尺寸，但是之前做过一个css3的宣传页动画，布局的时候需要子元素宽固定，但是拖动浏览器窗口大小，当浏览器窗口大小小于子元素宽度的时候样式乱了，此时，子元素里的内容，会相对于可视区定位。 5.定位+margin12345678910.p&#123; position:relative; &#125; .c&#123; position: absolute; left:50%; top:50%; margin-top:-25px;/*自身高度的一半*/ margin-left:-150px;/*自身宽度的一半*/ &#125; 子元素宽高必须设定为具体值，但是需要做适配的时候都不怎么使用绝对像素这种东西了。 其实，貌似哪种方案都多多少少有一定的局限，或许这才是每次做这种居中都要参考别人资料的原因吧。","categories":[],"tags":[{"name":"css布局","slug":"css布局","permalink":"http://yoursite.com/tags/css布局/"},{"name":"居中","slug":"居中","permalink":"http://yoursite.com/tags/居中/"}]},{"title":"清除浮动的四种方式","slug":"clearfix4Methods","date":"2017-06-10T05:54:48.000Z","updated":"2018-10-20T06:16:11.755Z","comments":true,"path":"2017/06/10/clearfix4Methods/","link":"","permalink":"http://yoursite.com/2017/06/10/clearfix4Methods/","excerpt":"1.W3C推荐，但是平白无故增加一个空标签，不可取，但是其他方式的原理都是这个12//在浮动元素的末尾添加一个空标签 &lt;div style=”clear:both”&gt;&lt;/div&gt;","text":"1.W3C推荐，但是平白无故增加一个空标签，不可取，但是其他方式的原理都是这个12//在浮动元素的末尾添加一个空标签 &lt;div style=”clear:both”&gt;&lt;/div&gt; 2.给浮动元素的父级添加overflow：hidden||auto||scroll12345.clearfix&#123; overflow:hidden;&#125;/*优点：代码简洁*//*缺点：内容增多时造成不会自动换行，导致内容被隐藏裁切*/ 3.after伪类清除浮动123456789 .clearfix:after &#123; content: \"\"; display: block; height: 0; clear: both;/*这个才是核心语句*/ visibility: hidden; &#125; .clearfix &#123;*zoom: 1;&#125; /* IE6、7 专有 *//*给浮动元素的直接父元素使用*/ 4.双伪元素清除浮动1234567891011.clearfix:before,.clearfix:after &#123; content:\"\"; display:table; &#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125;/*给浮动元素的直接父元素使用*/","categories":[],"tags":[{"name":"清浮动","slug":"清浮动","permalink":"http://yoursite.com/tags/清浮动/"}]},{"title":"有关JS循环","slug":"jsCircle","date":"2017-06-10T05:54:48.000Z","updated":"2018-10-20T06:16:05.320Z","comments":true,"path":"2017/06/10/jsCircle/","link":"","permalink":"http://yoursite.com/2017/06/10/jsCircle/","excerpt":"1.ECMAScript提供的方案1.1while循环123while(表达式)&#123; //执行语句&#125;","text":"1.ECMAScript提供的方案1.1while循环123while(表达式)&#123; //执行语句&#125; 1.2do…while循环123do&#123; //执行语句&#125;while(表达式) 2.数组循环2.1基本的for循环优化版本，效率最好 12345for（i = 0,len = arr.length;i&lt;len;i++）&#123; //循环arr数组arr = [1,2,3] //可以优化 console.log(arr[i]);&#125; 2.2基本的for…in循环(效率最👎)1234567891011//代码执行次数，取决于对象中有多少个属性//不仅可以遍历到对象的可枚举属性，该对象的构造函数原型上的可枚举属性也能够遍历得到var obj = &#123;a: 1, b: 2, c: 3&#125;;//我们给Object的原型加一个方法Object.prototype.fn = function()&#123; console.log('Grace');&#125;for(var key in obj)&#123; console.log(key);//a,b,c,fn console.log(obj[key]);//1,2,3,ƒ ()&#123;console.log('Grace');&#125;&#125; 数组的循环方法1234567891011121314var arr = [1,2,3];//forEacharr.forEach(function(value,index,currentArray)&#123; &#125;);//maparr.map(function(value,index)&#123; //value是数组对应的值， //index是数组的索引&#125;);//forEacharr.forEach(function(value,index)&#123; &#125;); 3.jQuery提供的循环方式123$.each(要循环的arr或obj,function(index,value)&#123; //to do list&#125;)","categories":[],"tags":[{"name":"循环","slug":"循环","permalink":"http://yoursite.com/tags/循环/"}]},{"title":"说说文件上传","slug":"about-upfiles","date":"2017-06-09T07:21:56.000Z","updated":"2018-10-10T12:32:52.100Z","comments":true,"path":"2017/06/09/about-upfiles/","link":"","permalink":"http://yoursite.com/2017/06/09/about-upfiles/","excerpt":"虽说，文件上传是一件非常常见的事情，几乎每个后台管理系统都有用到，也写了好几次，但每次写，不是这有问题就是那有问题，每次都是一顿查资料，今天详细说说文件上传，也好加深一下自己的记忆。","text":"虽说，文件上传是一件非常常见的事情，几乎每个后台管理系统都有用到，也写了好几次，但每次写，不是这有问题就是那有问题，每次都是一顿查资料，今天详细说说文件上传，也好加深一下自己的记忆。 0.文件上传PHP部分可能出现的问题： 1.文件名为中文可能出现乱码，不好解决 2.避免方案：设置哈希字符串（一串十六进制数据） ​ 优点：相同文件生成的哈希值一样，如果这个文件只有1字节内容的差异，它生成的哈希值就不一样，可以利用它唯一表示一个文件。这个可以保证服务器上不存在重复的资源。减少服务器负担。 12345678910111213141516171819202122232425&lt;?php header(\"Content-Type: application/json;charset=utf-8\"); //0.接收前端的文件数据，upfile是提前约定好的 $file_info = $_FILES['upfile']; //1.获得文件后缀 $name = $file_info['name']; $arr = explode('.',$name); $ext = array_pop($arr); //2.得到hash值， $md5_str = md5_file($file_info['tmp_name']); //3.计算保存路径，文件名，一般线上是全路径，这里只是为了测试 $save_file_name = \"./upload/\" . $md5_str . \".\" . $ext; //4.移动保存 move_uploaded_file($file_info['tmp_name'],$save_file_name); //5.返回给前端是否上传成功,成功返回地址，方便前端做上传预览 echo json_encode(array( \"success\" =&gt; true, \"url\" =&gt; $save_file_name )); ?&gt; 另外，对于这门世界上最好的语言，我只是简单了解，这个只是为了测试前端的代码。就像最后我还没了解到如何判断文件是否上传成功。另外对于macOS系统的用户，别忘了开文件夹权限，否则上传不了，如图。全部改成读与写。 1.原生图片上传+预览(H5) 采用H5新增的构造函数new FormData() html部分 1234567&lt;form action=\"\" method=\"post\"&gt; &lt;h3&gt;请选择文件&lt;/h3&gt; &lt;input type=\"file\" name='upfile' id=\"file\"&gt; &lt;button type=\"submit\"&gt;上传&lt;/button&gt; &lt;!--做上传预览--&gt; &lt;img src=\"\" alt=\"\" id=\"img\"&gt;&lt;/form&gt; js部分 123456789101112131415161718192021222324252627//采用ajax上传文件，像那种需要跳转的就不写了，用户体验不好，不用var oForm = document.querySelector('form');var oFile = document.querySelector('#file');var oImg = document.querySelector('#img');//实际上并不是点击表单的submit事件上传的图片，因为要做预览，oFile.onchange = function()&#123; //只要选择文件就预览 //1.使用FormDatas收集数据(H5引入的新的构造函数) var data = new FormData(); data.append('upfile',this.files[0]); //2.发送post请求, var xhr = new XMLHttpRequest(); xhr.open('post','./upload.php'); xhr.onreadystatechange = function()&#123; if(this.readyState === 4 &amp;&amp; this.status === 200)&#123; //字符串形式的json console.log(this.responseText); var obj = JSON.parse(this.responseText); if(obj.success)&#123; //上传成功就渲染img，预览 oImg.src = obj.url; &#125; &#125; &#125; xhr.send(data);&#125; 2.jQuery提供的文件上传 原生js看起来（bushi）有（yi）点麻烦，jQuery给我们做了很多默认处理，做一些配置就好 123456789101112131415161718192021222324$('#file').on('change',function()&#123; //1.使用formDate var data = new FormData(); data.append('upfile',$(this).get(0).files[0]); //2.发送ajax请求 $.ajax(&#123; url: './upload.php', type: 'post', data: data, /////////需要添加的配置信息 cache: false, contentType: false, progressData: false, ////////配置结束 success: function(info)&#123; console.log(info); if(info.success)&#123; //上传成功就渲染img，预览 //无需转换数据格式，因为jQuery 将自动根据 HTTP 包 MIME 信息来智能判断（预期） oImg.src = info.url; &#125; &#125; &#125;);&#125;); 其实，如果是想要传多个文件，我们只需要在data里多次append就好了。其实还有很多文件上传插件😄","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"文件上传","slug":"文件上传","permalink":"http://yoursite.com/tags/文件上传/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"常用mySQL语句","slug":"mySQl","date":"2017-01-13T11:09:23.000Z","updated":"2018-10-20T06:15:11.439Z","comments":true,"path":"2017/01/13/mySQl/","link":"","permalink":"http://yoursite.com/2017/01/13/mySQl/","excerpt":"mySQL在大学里学了两遍，一个是基于运用的，上来就讲实例，一个是原理的，数据库原理概论。感觉有一整年的事件都在学这个，可见重要性，今天总结一下很常用的几个语句，加深一下印象。","text":"mySQL在大学里学了两遍，一个是基于运用的，上来就讲实例，一个是原理的，数据库原理概论。感觉有一整年的事件都在学这个，可见重要性，今天总结一下很常用的几个语句，加深一下印象。 1.数据查询语法格式 : 123456789SELECT 字段名1, 字段名2, ...... FROM 表名 [ WHERE &lt;条件表达式&gt; ] [ ORDER BY &lt;字段名&gt; [ ASC|DESC ]] [ LIMIT START, LENGTH] 1.1基本查询语法格式： 1select 字段名1, 字段名2,.... from 表名 例如: 查询管理员的id，昵称 1select admin_id,admin_nickname from tab-admin 出于性能考虑，一般不写‘*’ 1.2where（条件）查询年龄在23-28之间的管理员的所有信息 where 可以使用条件来筛选查询出的结果，例子 1select * from tab-admin where admin_age&gt;=23 and admin_age&lt;=30 或者：between…and 1select * where admin_age between 23 and 28 查询年龄不在23-28之间的管理员的所有信息 1select * where admin_age&lt;23 or admin_age&gt;28 或者：not between and 1select * where admin_age not between 23 and 28 注意：mysql的条件里没有不等于，可以用大于小于模拟不等于 1.3in（枚举）查询年龄为20、28的女性管理员信息 1select * from tab-admin where admin_gender=&apos;女&apos; and （admin_age=20 or admin_age=28） 或者 in 1select admin_id from tab-admin where admin_gender=&apos;女&apos; and admin_age in（20,28） 1.4模糊查询通配符: % : 代表任意长度(包括0)的任意字符 _ : 代表1位长度的任意字符 like: 在执行模糊查询时，必须使用like来作为匹配条件 查询邮箱地址中包含字符sina的管理员信息 1select * from tab-admin where admin_email like &apos;%sina%&apos;; 1.5order by （顺序）order by 可以对查询结果按某个字段的升降进行排序 升序 asc （默认值） ， 降序 desc 可进行排序的字段通常是 整型 英文字符串型 日期型 (中文字符串也行,但一般不用) 例如：查询所有管理员信息，按照id的降序查找 1select * from tab-admin order by admin_id desc 1.6limit限制(可用于分页)limit用来限制查询结果的起始点和长度 格式: limit var1, var2 var1: 起始点。 查询结果的索引，从0开始。 0代表第一条数据 var2: 长度 例如：查询年龄最大的3名男性管理员的信息 1select * from tab-admin where admin_gender=&apos;男&apos; order by admin_age desc limit 0,3; 1.7多表查询关键词: join on 语法格式: ​ select * from 表1 join 表2 on 链接条件 链接条件一定是 表1的某个字段 = 表2的某个字段 例子：查询学生的全部信息，系别需要使用系名来进行显示 1select tab-stu.*,tab-dept.dept_name from tab-stu join tab-dept on sdept=dept_id; 2.添加数据格式： insert into 表名(字段1，字段2，…) values(值1，值2，…); 关键点: 1) 字段和值需要一一对应，如果不对应会造成添加失败或者数据错误 2) 如果每个字段都有数据，则不需要在表名后设置字段列表 3) 带有auto_increment属性的字段可以使用null来设置，MySQL会自动填充数据 例子：向student表添加一条数据 1insert into tab-stu(sno,sname,sgender,sage) values(6,&apos;Grace&apos;,&apos;女&apos;,20); 如果每个字段都需要设置，那么可以不列出字段名，但是顺序要有保证 1insert into tab-stu values(null,&apos;Grace&apos;,&apos;女&apos;,20); 有auto_increment属性的字段，mysql会自动填充。 或者： 1insert into tab-stu set `字段名1`=value1,`字段名2`=value2...; 还是比较常用的 3.修改数据语法格式: update 表名 set 字段1=值1, 字段2=值2,... where 修改条件 修改表中的哪一条（几条）数据的 字段1=值1... 例子：将所有男性管理员的年龄都+1 1update tab-admin set admin_age=admin_age+1 where admin_gender=&apos;男&apos;; 4.删除数据语法格式: delete from 表名 where 删除条件 例子：删除id=5的管理员 1delete from tab-admin where admin_id=5; 一般是不删除数据的，都只是在做修改，比如删除会把isdelete字段改为true，表示删除数据。","categories":[],"tags":[{"name":"mySQL基本语句","slug":"mySQL基本语句","permalink":"http://yoursite.com/tags/mySQL基本语句/"}]},{"title":"搭建一个基于github和hexo的博客","slug":"hellohexo","date":"2017-01-12T14:00:09.000Z","updated":"2018-09-20T09:41:10.524Z","comments":true,"path":"2017/01/12/hellohexo/","link":"","permalink":"http://yoursite.com/2017/01/12/hellohexo/","excerpt":"这是我的第一篇博客，我只想用它来记录学习路程，之前项目遇见问题，我会查别人的博客，意识到了分享的重要性，于是开始将我的写作放到博客上来。如果有不对的地方，希望大家多多批评指正。","text":"这是我的第一篇博客，我只想用它来记录学习路程，之前项目遇见问题，我会查别人的博客，意识到了分享的重要性，于是开始将我的写作放到博客上来。如果有不对的地方，希望大家多多批评指正。 1.首先你需要安装git和node环境，假如你安装了node，npm是默认安装的。 2.安装hexo你可以先检查一下是否安装了hexo。 1$ hexo -v 如果没有输出版本号，接着安装 1$ npm i hexo -g 3.创建git仓库登陆你的git账号，建立一个仓库，这个仓库名字必须是 用户名.github.io,并且一个github账号只能注册一个博客地址。本文所有的用户名都代表你的github用户名 4.创建本地博客文件夹在你喜欢的任何地方创建一个文件夹，用来创建本地博客，打开终端，cd到这个文件夹，初始化hexo 1$ hexo init 这个过程有可能会报安装依赖失败的error，我在win10上没有遇见，在mac上遇见了，此时安装依赖，即执行 1$ npm install 初始化完成之后，你就可以在本地预览你的博客了，启动服务器，s是server的意思，即执行 1$ hexo s 在本地浏览器地址栏输入http://localhost:4000/可以本地预览你的作品。不过可能看起来似乎有点low。但后期是可以更改主题的。 5.将本地博客推送至远程git仓库找到本地博客文件夹，根目录的_config.yml，拉到最后修改一个配置，注意冒号后有一个空格，每个键名前是两个空格。末尾不要留下空格 1234deploy: type: git branch: master repository: https://github.com/用户名/用户名.github.io.git 开始准备上传 1$ hexo g 上传 1$ hexo d 我在此处出错了，执行下面命令 1$ npm i hexo-deployer-git 下载完依赖之后再次执行 1$ hexo d 上传成功，在浏览器上访问你的用户名.github.io,就可以访问了 6.如何增加博客？在你博客文件夹下运行终端，创建一篇文章 1$ hexo new 文章名字 找到根目录下的source/_posts文件夹，你刚创建的博客md文档就出现了，你就可以在这里编写你的博客了，写好之后你预览了没问题就可以上传 12$ hexo g $ hexo d 7.修改主题如果你不喜欢那种原生的田园风格，可以尝试更换主题，我采用的主题是https://github.com/litten/hexo-theme-yilia,具体配置方案上面有文档，需要注意的是头像的图片地址放在yilia/source下路径，具体你想放在哪里写在yilia/_config.yml配置文件里就行啦！另外这是主题的中文文档地址http://moxfive.coding.me/yelee/ 8.绑定域名 这个要看你想不想绑定了，我是之前就有购买域名，所以用在了这里 1.如果你的域名需要实名认证，请提前认证，大概需要两三天吧。 2.获取github的IP地址：终端 ping 用户名.github.io记录下IP地址，这个IP是要和你的域名绑定的。 3.我是在阿里云购买的域名，登录&gt;控制台&gt;域名&gt;解析&gt;添加记录 CNAME记录值是你的用户名.github.io A对应的记录值是你刚才ping到的IP地址 4.根目录下的&gt;_config.yml修改skip_render: CNAME 5.在你的本地的文件夹根目录&gt;source下创建一个没有后缀的，名为CNAME的文件，里面写上你的域名，注意写错了报404，之后hexo -gand hexo -d 之后大功告成。试试用你的域名访问你的博客吧！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]