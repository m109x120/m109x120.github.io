[{"title":"ES6","slug":"ES6","date":"2018-09-17T11:02:23.000Z","updated":"2018-09-20T09:40:00.240Z","comments":true,"path":"2018/09/17/ES6/","link":"","permalink":"http://yoursite.com/2018/09/17/ES6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"react基本语法特征","slug":"react-basic-928-0","date":"2018-03-28T03:51:13.000Z","updated":"2018-09-28T04:00:49.301Z","comments":true,"path":"2018/03/28/react-basic-928-0/","link":"","permalink":"http://yoursite.com/2018/03/28/react-basic-928-0/","excerpt":"总结一下基本的react语法，以及特有的jsx，组件传值，包括子组件修改父组件的数据，兄弟组件的通信，实际上也就是单向数据流的概念。","text":"总结一下基本的react语法，以及特有的jsx，组件传值，包括子组件修改父组件的数据，兄弟组件的通信，实际上也就是单向数据流的概念。 1.react的优点react本身只是一个视图层的框架，它抛弃了传统的继承模式，采用组件化的方式开发，采用了jsx表达式，jsx只有在react里才有的，用来处理数据和DOM的关系，不需要我们操作DOM，不同于art-template等之类的模版字符串，它采用虚拟DOM的方式减少低效的DOM操作。 2.jsx基础语法 基本用法，样式用法，变量的使用，逻辑的处理 1234567891011121314151617181920212223242526272829//导入react，react-domimport React from 'react';import ReactDOM from 'react-dom';let obj = &#123; name: 'Grace', flag: true&#125;;let arr = ['Apple','ml','oppo'];let style = &#123; color:'r'+'ed', fontSize: 30+20+'px' //虽然直接加样式的方式不常用，但它支持逻辑，&#125;;let jsx = ( &lt;div style=&#123;style&#125; className='jsx'&gt; &#123;/*条件判断与变量的使用*/&#125; &#123; obj.flag ? &lt;p&gt;I am &#123;obj.name&#125;&lt;/p&gt; : &lt;p&gt;I am not &#123;obj.name&#125;&lt;/p&gt; &#125; &#123;/*数组循环*/&#125; &#123; arr.map((name,index) =&gt; &lt;p key=&#123;index&#125;&gt;第&#123;index&#125;号商品:&#123;name&#125;&lt;/p&gt;) &#125; &lt;/div&gt;);ReactDOM.render( jsx, document.querySelector('#app')); 3.react组件（ES6）本段代码包含，数据传递，修改数据，以及事件绑定 123456789101112131415161718192021222324252627282930313233343536373839class Compontent extends React.Component&#123; constructor(props)&#123; //父组件向子组件传递数据 super(props); this.state = &#123; age: 18 &#125; &#125; handelClick()&#123; //修改自身的数据 this.setState(&#123; age : this.state.age+1 &#125;); &#125; handelChange(e)&#123; this.setState(&#123; age : e.target.value &#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;I am &#123;this.props.name&#125;,我今年 &#123;this.state.age&#125; 岁了&lt;/h1&gt; &#123;/*在事件绑定上使用了箭头函数，这是利用了，ES6箭头函数自身没有this的概念，它继承自父类 的 this，正好使用这种方式，我们无需重新绑定this*/&#125; &lt;button onClick=&#123;(e)=&gt;&#123;this.handelClick(e)&#125;&#125;&gt;加一岁&lt;/button&gt; &lt;input type=\"text\" onChange=&#123;(e)=&gt;&#123;this.handelChange(e)&#125;&#125;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( //只能是一层 &lt;div&gt; &lt;Compontent name='Grace'/&gt; &lt;Compontent name='Jack'/&gt; &lt;/div&gt;, document.querySelector('#app')); 4. 组件之间的关系容器式与单纯组件写法123456789101112131415161718192021222324252627282930313233343536class Compontent extends React.Component&#123; render()&#123; return ( &lt;h2&gt;Compontent&lt;/h2&gt; ) &#125;&#125;class Title extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;h1&gt;&#123;this.props.children&#125;&lt;/h1&gt; ) &#125;&#125;class App extends React.Component&#123; render()&#123; return( &lt;div className=''&gt; &#123;/*容器式组件*/&#125; &lt;Title&gt; &lt;h2&gt;App h2&lt;/h2&gt; &lt;/Title&gt; &lt;hr/&gt; &#123;/*单纯组件*/&#125; &lt;Compontent/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;App /&gt;, document.querySelector('#app')); 我们发现，父组件向子组件传值很方便，通过props，但是子组件向父组件传值如何实现？兄弟组件呢？ 5. 组件传值5.1父组件向子组件传值：props5.2子组件修改父组件的值其实，我们没办法在子组件里修改父组件的值，props传来的数据是只读的，但是我们可以告诉父组件我想让你帮我把某个数据改掉，这个我们可以通过回调来处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 父子组件的数据通信// 子组件想要改变父组件的样式class Children extends React.Component&#123; constructor(props)&#123; super(props); &#125; handelClick(e)&#123; // 我们可以通过props得到父组件传来的fontColor // console.log(this.props.bgColor); // 我们无法直接修改props，因为它是只读数据 // 我们可以采用回调的形式，来告诉父组件，我想要修改某个值，而实际上还是虽然是在子组件里面点击了按 //钮，但是触发修改数据的是父组件，因为单向数据流，数据在父组件身上呢。 this.props.colorChange('red'); &#125; render()&#123; return ( &#123;/*第一层大括号是表达式，第二层大括号是json结构*/&#125; &lt;div style=&#123;&#123;background:this.props.bgColor&#125;&#125;&gt; &lt;button onClick=&#123;(e)=&gt;&#123;this.handelClick(e)&#125;&#125;&gt;改变父组件的bgColor颜色 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class Father extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123; bgColor : 'green' &#125; &#125; onBgColorChange(color)&#123; // color值是从子组件传来的，只要有值传过来，就能触发这个事件 this.setState(&#123; bgColor: color &#125;) &#125; render()&#123; return( &lt;div style=&#123;&#123;background:this.state.bgColor&#125;&#125;&gt; &lt;h1&gt;父组件背景色：&#123;this.state.bgColor&#125;&lt;/h1&gt; &#123;/* 调用子组件，并传值进去 */&#125; &lt;Children colorChange=&#123;(color)=&gt;&#123;this.onBgColorChange(color)&#125;&#125;/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Father/&gt;, document.querySelector('#app')); 5.3兄弟组件传值用到了变量提升，把需要更改的值，以及更改操作都放在父组件里。因为单项数据流的原因，当父组件的值发生改变，会向下传递到子组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Children1 extends React.Component&#123; // 接收父组件传值 constructor(props)&#123; super(props); &#125; handelClick()&#123; this.props.changeChild2Color('yellow'); &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;child1:&lt;/h2&gt; &lt;button onClick=&#123;(e)=&gt;&#123;this.handelClick(e)&#125;&#125;&gt;改变child2的背景颜色&lt;/button&gt; &lt;hr/&gt; &lt;/div&gt; ) &#125;&#125;class Children2 extends React.Component&#123; // 接收组件传来的值 constructor(props)&#123; super(props); &#125; render()&#123; return ( &lt;div style=&#123;&#123;color:this.props.bgColor&#125;&#125;&gt; &lt;h2&gt;child2: &#123;this.props.bgColor&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;class Father extends React.Component&#123; constructor(props)&#123; super(props); // 把应该在child2里的数据保存在父组件中，叫状态提升 this.state = &#123; child2BgColor: 'red' &#125; &#125; changeColor(color)&#123; // console.log(color); yellow传过来了 this.setState(&#123; child2BgColor: color &#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;Children1 changeChild2Color=&#123;(color)=&gt;&#123;this.changeColor(color)&#125;&#125;/&gt; &lt;Children2 bgColor=&#123;this.state.child2BgColor&#125;/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Father/&gt;, document.querySelector('#app')); 6.react声明周期生命周期是一个组件从生到死的整个过程 6.1Mounting挂载(渲染)阶段最先出现的是： 1constructor()&#123;&#125; 组件将要渲染： 1componentWillMount()&#123;&#125; 组件渲染： 1render()&#123;&#125; 组件渲染完成： 1componentDidMount()&#123;&#125; 简单测试一下 12345678910111213141516171819class Test extends React.Component&#123; constructor(props)&#123; super(props); console.log('Mount: constructor'); &#125; componentWillMount()&#123; console.log('Mount: componentWillMount'); &#125; componentDidMount()&#123; console.log('Mount: componentDidMount'); &#125; render()&#123; console.log('render'); return ( &lt;h1&gt;hahah&lt;/h1&gt; ); &#125;&#125; 执行结果：Mount: constructor-&gt;Mount: componentWillMount-&gt;render-&gt;Mount: componentDidMount 6.2 Updating运行时阶段(组件更新引起的变化)自更新是没有钩子的，只有是父组件修改数据才能触发 将要接收父组件传来的props 1componentWillReceiveProps()&#123;&#125; 子组件是否需要更新 1234shouldComponentUpdata()&#123; //这个方法返回false后面的都不再执行 return true;&#125; 子组件将要更新 1compontentWillUpdata()&#123;&#125; 子组件更新 1render()&#123;&#125; 子组件更新完成 1compontentDidUpdate()&#123;&#125; 同样测试一下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Test extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; content: 'haha' &#125; console.log('Mount: constructor'); &#125; componentWillMount()&#123; console.log('Mount: compontentWillMount'); &#125; handelClick()&#123; this.props.changeContent('Grace'); &#125; render()&#123; console.log('render'); return ( &lt;h1 onClick=&#123;()=&gt;&#123;this.handelClick()&#125;&#125;&gt;&#123;this.props.content&#125;&lt;/h1&gt; ); &#125; componentDidMount()&#123; console.log('Mount: compontentDidMount'); &#125; componentWillReceiveProps()&#123; console.log('Updating: componentWillReceiveProps'); &#125; shouldComponentUpdate()&#123; console.log('Updating: shouldComponentUpdate'); return true; &#125; componentDidUpdate()&#123; console.log('Updating: componentDidUpdate'); &#125;&#125;class F extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; content: 'haha' &#125; &#125; setContent(context)&#123; this.setState(&#123; content: context &#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;Test content=&#123;this.state.content&#125; changeContent=&#123;(context)=&gt;&#123;this.setContent(context)&#125;&#125;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;F/&gt;, document.querySelector('#app')); 执行结果：Updating: componentWillReceiveProps-&gt;Updating: shouldComponentUpdate-&gt;render-&gt;Updating: componentDidUpdate 6.3Unmounting卸载阶段组件将要销毁 123compontentWillUnmount()&#123; //如果做了定时器，在销毁前要清定时器，以减少性能消耗&#125; 6.4Error Handing错误处理(react16独有)这种错误并不是逻辑错误，只处理在render时候的错误 还有其他非常重点的东西，下次总结路由：React-Router ，很有意思，牵扯的历史的东西也是很多。react生态系统很庞大，有一定的学习成本","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"jsx","slug":"jsx","permalink":"http://yoursite.com/tags/jsx/"},{"name":"react组件传值","slug":"react组件传值","permalink":"http://yoursite.com/tags/react组件传值/"},{"name":"生命周期","slug":"生命周期","permalink":"http://yoursite.com/tags/生命周期/"}]},{"title":"react开发打包环境的搭建","slug":"reactProductEnvironment","date":"2018-03-18T14:30:07.000Z","updated":"2018-09-27T12:15:30.832Z","comments":true,"path":"2018/03/18/reactProductEnvironment/","link":"","permalink":"http://yoursite.com/2018/03/18/reactProductEnvironment/","excerpt":"总结一下搭建react开发环境基本过程，以及在搭建过程中遇见的大坑，小坑。。。","text":"总结一下搭建react开发环境基本过程，以及在搭建过程中遇见的大坑，小坑。。。 1.git的安装和配置 git安装(想必都会，只总结mac系统遇到的问题) 官网下载git的.dmg安装包，双击打开，双击.pkg的安装包，😯，报错了…打不开身份不明开发者。这是由于mac安全限制外部下载的软件。 解决方案：打开系统偏好设置&gt;安全与隐私&gt;通用：提示已阻止打开“git-…pkg”,因为来自身份不明的开发者。倔强地选择仍要打开。 接着傻瓜式下一步…ok。 检测是不是安装成功了(成功输出git的版本号) 1$ git --version 配置.gitconfig(它是一个用户目录下的隐藏文件，终端ls看不见隐藏文件，ls -all可以看见) 1$ vim ~/.gitconfig 进来之后，用小写字母i进入编辑模式，user不配置首次提交的时候也会让你输入，这里的email是注册git的时候使用的邮箱。alias是git命令简写，我只配了一些常用的。 123456789101112[user] name=Grace email=***@163.com[alias] co=checkout ci=commit st=status pl=pull ps=push dt=difftool ca=commit -am b=branch 写好之后按ESC推出编辑模式，输入:wq+回车保存并退出.gitconfig的编辑模式，我们还可以查看刚才的配置信息。 1$ cat ~/.gitconfig 2.项目的建立 获取ssh密钥邮箱是刚才配置的那个，执行完这条命令之后，一直回车到执行完 1$ ssh-keygen -t rsa -C '***@163.com' 此时会在用户目录下生成一个.ssh的文件夹，cd到这个文件夹,ls-all查看所有文件，那个id_rsa.pub就是存放公钥的文件 1$ cat id_rsa.pub 查看公钥内容，复制下来。 打开gitee.com，码云在国内，速度快。 创建一个项目&gt;管理&gt;部署公钥管理&gt;公钥管理&gt;添加个人共钥，把刚才在终端复制的公钥贴进来。 then可以把远程项目代码clone到本地了，克隆下载 &gt; 选择ssh，因为刚才已经添加过个人公钥了。 在用户目录下新建一个空文件夹用于存放项目，cd 到这个文件夹，git clone～～～，远程代码成功拉到本地。现在远程和本地已经建立起来了。 我们还需要添加一个.gitignore文件，忽略我们不需要push到仓库的文件 1$ vim .gitignore 输入i进行编辑 1234.DS_Storenode_modulesdist*.log ESC :wq+回车 保存成功，push到远程 3.安装node.js和yarn安装过程非常简单，记得指定版本。（node的安装官网很详细） 为什么不用node自带的npm? 因为yarn安装速度快，这种快并不仅仅是服务器快，而且并行下载，还有牛掰的缓存机制，之前装过的包是走缓存的，可以断网使用，到秒装效果。 yarn与npm的语法对比 Yarn Npm yarn init npm init yarn npm install yarn global add xxx@x.x.x npm install xxx@x.x.x -g yarn add xxx@x.x.x npm install xxx@x.x.x –save yarn add xxx@x.x.x –dev npm install xxx@x.x.x –save-dev yarn remove xxx npm uninstall xxx –save(-dev) yarn run xxx npm run xxx 4.初始化项目上一步安装完了node和yarn，cd到项目文件夹，初始化yarn，提示出的信息我们可以不填写，走默认的。 1$ yarn init git st-&gt;git add .-&gt;git ca &quot;yarn init&quot;-&gt;git ps将文件推送到远程仓库 5.webpack的安装和配置5.1.webpack概念前端资源打包工具，html，css，脚本，字体等资源都会被看作一个模块，都会被打包到js里。 5.2.多版本共存的解决方案全局只能安装一个啦，俩项目又不想使用同一个版本怎么搞啦！为了避免冲突，我们不可能在全局安装两个版本的webpack，node_modules&gt;.bin下面有一个可执行的webpack文件，使用这种方式，可以避免影响。webpack的安装。cd到项目根目录，为了避免冲突，这里所用到的所有工具，我都安装在项目里，不在全局安装。 1$ yarn add webpack@3.10.0 --dev 5.3.entry在项目根目录下新建一个webpack.config.js, 12345678const path = require('path');module.exports = &#123; entry: './src/app.js', //这是需要打包的文件路径，配置react的时候会改为jsx后缀 output: &#123; path: path.resolve(__dirname,'./dist'), //打包到目标文件夹 filename: 'app.js' //打包成功后的文件命名方式 &#125;&#125; 可以在src&gt;app.js随便写点东西，测试一下webpack是不是打包成功了。(下面的命令貌似有点长，最后再解决这个问题) 1$ node_modules/.bin/webpack 成功打包js～ 5.4.html安装htmlwebpackplugin插件，最好是指定版本（另外你安装了啥都在package.json文件里，这是yarn为我们自动生成的） 1$ yarn add html-webpack-plugin@2.30.1 --dev 配置htmlwebpackplugin插件 1234567891011//在webpack.config.js里引入htmlwebpackplugin插件const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; . . . //接着刚才的入口出口 写htmlwebpackplugin的配置 plugin: [ new HtmlWebpackPlugin() ]&#125; 打包一次试试看看什么效果，打包方式同entry里的方法。dist文件夹下多一个index.html文件，它默认引入了dist&gt;app.js文件，但是看起来好像跟我们想要的不太一样，有些标签没加，比如视口大小没有定义等等。我们可以指定模版,在src文件夹下新建一个index.html把这个文件作为模版。 123456plugin: [ new HtmlWebpackPlugin(&#123; //引用模版文件,这个文件默认的输出就是dist&gt;index.html template: './src/index.html' &#125;)] 5.5.脚本5.5.1.ES6语法在项目根目录下安装babel相关的插件，用于打包ES6的语法 1$ yarn add babel-core@6.26.0 babel-preset-env@1.6.1 babel-loader@7.1.2 --dev 配置webpack.config.js 12345678910111213141516171819202122232425262728module.exports = &#123; entry: './src/app.js', //使用react之后，文件后缀是jsx,与入口文件后缀保持一致 output: &#123; path: path.resolve(__dirname,'./dist'), filename: 'app.js' &#125;, //babel的配置开始 module: &#123; rules: [ &#123; test:/\\.js$/, //使用react之后文件后缀改为了jsx exclude: /(node_modules)/, //对参数不做处理 use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ] &#125;, //babel配置结束 . . .&#125; 之后在src&gt;app.js里写入ES6语法的代码，之后打包，我们会发现dist&gt;app.js里面已经被转为ES5的语法了。 5.5.2 react语法处理（相对好搞的部分）项目根目录装插件 1$ yarn add babel-preset-react@6.24.1 --dev 配置webpack.config.js，在刚才配置babel的preset环境中添加react,把js文件后缀改为jsx就ok了。 1presets: ['env react'] 安装react，这是我们代码里要用的，不是生产工具 1$ yarn add react@16.2.0 react-dom@16.2.0 在src&gt;app.jsx下书写react代码，打包成功啦～ 5.6.样式需要配置style-loader，css-loader ，sass-loader 5.6.1 安装style-loader和css-loader1$ yarn add style-loader@0.19.1 css-loader@0.28.8 --dev 修改配置文件，在rules中的react语法后接着配置 123456789//style-loader与css-loader的配置信息&#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ]&#125;//style-loader与css-loader的配置信息结束 在src&gt;新建index.css,写点样式，在src&gt;app.jsx中引入css 1import './index.css' 打包成功，css被打包到dist&gt;app.js中，我测试的dist下的文件，样式生效～，但是以这种方式打包出来的样式要等到所有js加载完成之后css在执行，有可能会出现网页裸奔效果，所以，我们应该想办法把它单独放在一个css文件里，然后 打包后 dist&gt;app.js已经引入～ 安装extract-text-webpack-plugin 1$ yarn add extract-text-webpack-plugin@3.0.2 --dev 配置webpack.config.js，把刚才配置的css里的use改为下面的代码,另外需要引入，new插件 123456789101112131415161718192021222324252627282930//extract-text-webpack-plugin 引入const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; . . . module: &#123; rules: [ //react语法的处理 . . . //css文件的处理 &#123; test: /\\.css$/, //extract-text-webpack-plugin use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) //extract-text-webpack-plugin &#125; ] &#125;, plugin: [ //extract-text-webpack-plugin 生成文件的位置 new ExtractTextPlugin('index.css') //extract-text-webpack-plugin ]&#125; 打包成功，～，css自动被引入了， 5.6.2处理sass安装sass-loader 1$ yarn add sass-loader@6.0.6 --dev 在webpack.config.js的module里的css文件的处理后，添加 12345678//sass文件的处理&#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: ['css-loader','sass-loader'] &#125;)&#125; 在src下面新建一个scss文件，在app.jsx中引入这个文件，打包成功，成功，，，哎？尼玛，报错了。。。而且还是scss文件的语法错误，尼玛三行测试代码有错，不科学呐～ 一顿找。。 因为，sass-loader依赖node-sass和webpack,赶紧安装一下，此包安装的时间可真久， 1$ yarn add node-sass@4.7.2 --dev 这回打包成功了～ 5.7图片和静态文件的处理 这或许有点麻烦了 5.7.1 图片的配置安装url-loader,url-loader依赖file-loader 1$ yarn add file-loader@1.1.6 url-loader@0.6.2 --dev 在刚才的webpack.config.js中的sass文件处理后接着写 12345678910111213//图片的配置&#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 //小于这个大小的图片资源直接转成base64 name: 'resource/[name].[ext]' //文件打包后的位置 &#125; &#125; ]&#125; 可以试试一张图片是不是被打包成功了， 5.7.2 配置字体（font-Awesome）安装一个font-Awesome 1$ yarn add font-awesome 配置webpack.config.js，接着图片处理写 12345678910111213//字体的处理&#123; test: /\\.(eot|svg|ttf|woff|woff2|otf)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 name: 'resource/[name].[ext]' //文件打包后的位置 &#125; &#125; ]&#125; 打包成功，dist目录多了很多文件。 5.7.3 通用模块提取的插件在webpack.config.js的plugin中 1234567891011121314const webpack = require('webpack'); plugins: [ //处理html文件 . . . //独立css文件 new ExtractTextPlugin('css/[name].css'), //提出公共模块的插件 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'common', filename: 'js/base.js' //通用的文件被打包到这个文件里 &#125;)] 5.7.4 webpack-dev-server 自动刷新安装webpack-dev-server 1$ yarn add webpack-dev-server@2.9.7 --dev 在webpack .config.js的最后，在出口里，定一个一个公共路径，不然后字体文件找不到路径，因为服务器是从根目录开始找的 12345678output: &#123; path: path.resolve(__dirname,'./dist'), publicPath: '/dist/', filename: 'js/app.js'&#125;,devServer: &#123; port: 8086 //默认的8080端口可能会被占用，所以修改&#125; 之后每改动一次文件，浏览器是自动刷新的。 最后一步，在package.json中配置一些脚本，只是有些命令太长了， 1234\"scripts\": &#123; \"dev\": \"node_modules/.bin/webpack-dev-server\", \"dist\": \"node_modules/.bin/webpack -p\" //线上环境的打包&#125;, yarn run dev就可以开启本地服务，会默认打包的， 到此，一个简单的react开发环境搭完成，但是，，这并不是最终的，这只是最简单的配置，在开发过程中还会进行别的配置。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"原生ES5里的一道有趣的题目","slug":"js-es5","date":"2018-01-20T15:26:52.000Z","updated":"2018-09-21T08:05:40.183Z","comments":true,"path":"2018/01/20/js-es5/","link":"","permalink":"http://yoursite.com/2018/01/20/js-es5/","excerpt":"咋一看最后俩有点蒙了，可能是我一般不这么写的原因，很考察JS基础的一道题目，哎～，对了，你高程刷几遍了？据说这是美团的一道面试题，但是貌似也是面试中常见的题目。如果你对我的分析有别的见解，还请多多指教！","text":"咋一看最后俩有点蒙了，可能是我一般不这么写的原因，很考察JS基础的一道题目，哎～，对了，你高程刷几遍了？据说这是美团的一道面试题，但是貌似也是面试中常见的题目。如果你对我的分析有别的见解，还请多多指教！ 先看题目，假设弹出几就给函数编号为几号1234567891011121314151617181920212223242526function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;Foo.getName = function () &#123; console.log (2);&#125;;Foo.prototype.getName = function () &#123; console.log(3);&#125;;var getName = function () &#123; console.log (4);&#125;;function getName() &#123; console.log (5);&#125;// 请写出一下的输出结果Foo.getName(); //1行getName(); //2行Foo().getName(); //3行getName(); //4行new Foo.getName(); //5行new Foo().getName(); //6行new new Foo().getName();//7行 我看到的时候，答对了前五道。后两道请教了大牛才明白，看来还是得多看高程啊。 1 .预解析首先，ES5对，var,function关键字声明的变量，函数进行预解析。 本段代码预解析之后，我们得到 123456789function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;var getName = function () &#123; console.log (5);&#125;; 2.代码执行虽然预解析过程中，getName被赋值为代码块，但是，在执行 123var getName = function () &#123; console.log (4);&#125;; 的时候全局的getName函数被重新赋值给四号函数。所以在执行输出之前我们得到的是 123456789101112//Foo整体代码块function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;//此间var getName被预解析为undefined，但是之后的getName函数进行了覆盖。//getName整体代码块var getName = function () &#123; console.log (4);&#125;; 在执行输出之前，必须明确的是： 1号getName函数没有关键字this，它不是Foo的私有函数，此处的getName函数只是在修改全局的getName函数。2号函数是Foo上的方法，Foo的实例对象打点无法调用到。 开始执行 行号 分析 结果 1 Foo身上的getName方法一直都是2 2 2 全局的getName现在是4 4 3 Foo执行会修改全局的getName为1，返回值是它的调用者，这里没写，默认window，打点调用window的getName方法得到的是：1 1 4 getName();全局的getName执行 1 5 这个时候并没有先执行new调用Foo，new运算符的优先级没有点的高，而是先执行了Foo.getName。现在就是在new function () {console.log (2);} 2 6 虽然我们在new调用构造函数的时候()的作用是传参，但是在接着打点调用它原型上的方法的时候，括号的作用就是不仅仅是传参了，而是可以提高new运算符的优先级。所以这段代码，先new Foo()返回Foo的实例对象，调用实例对象身上的方法getName方法， 3 7 new new Foo().getName();相当于new Foo的实例对象的getName方法 。new function () {console.log(3);}; 3 总结：几行代码，大坑小坑不断，虽然这个时候通了，但我可能过一段时间会遗忘，给自己立一个里程碑，学习，不仅仅是要向前走，还要把所学东西分门别类的整理好。另外记录一些题外话，最近，我老能提前感知未来发生的事情，第六感准到自己都会半夜被吓醒，我究其原因：我近一年的业余时间，都在研究这个事情，要是我能把这个尽头放在前端上，又或者是股票，那我岂不是要达到很高的境界了。～加油Grace～","categories":[],"tags":[{"name":"ES5","slug":"ES5","permalink":"http://yoursite.com/tags/ES5/"},{"name":"预解析","slug":"预解析","permalink":"http://yoursite.com/tags/预解析/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"后端设定CORS，能访问数据接口，但是cookie，session无法冲破跨域限制","slug":"CORS-928-0","date":"2017-09-27T12:08:45.000Z","updated":"2018-09-29T07:43:36.383Z","comments":true,"path":"2017/09/27/CORS-928-0/","link":"","permalink":"http://yoursite.com/2017/09/27/CORS-928-0/","excerpt":"跨域导致的问题，后端开启CORS后，虽然能访问后端接口，但是会话机制没办法冲破跨域限制。做登录时候出现问题，我把前端代码放在本地Apache服务器上，他默认80端口，node提供数据，默认3000端口，此时我通过ajax访问数据，肯定会出现跨域问题。。。","text":"跨域导致的问题，后端开启CORS后，虽然能访问后端接口，但是会话机制没办法冲破跨域限制。做登录时候出现问题，我把前端代码放在本地Apache服务器上，他默认80端口，node提供数据，默认3000端口，此时我通过ajax访问数据，肯定会出现跨域问题。。。 1.配置apache反向代理1.1 配置httpd.conf打开httpd.conf 开启如下模块，行号参考，不一定准确 123LoadModule proxy_module libexec/apache2/mod_proxy.so ---132行LoadModule proxy_http_module libexec/apache2/mod_proxy_http.so ---135行Include /private/etc/apache2/extra/httpd-vhosts.conf ---517行 1.2 配置httpd-vhosts.conf打开下面的文件配置域名与反向代理，具体路径，按自己的来。 1234567891011121314151617&lt;VirtualHost *:80&gt; DocumentRoot \"/Users/grace/ymx\" ServerName www.ymx.com ServerAlias ymx.com &lt;Directory \"/Users/grace/ymx\"&gt; Options Indexes FollowSymLinks ExecCGI DirectoryIndex AllowOverride All Order allow,deny Allow from all Require all granted &lt;/Directory&gt; #开启反向代理 ProxyRequests Off #使用/api代替http://localhost:3000，不要照搬，是啥就写啥，/api也是想叫啥就叫啥 ProxyPass /api http://localhost:3000&lt;/VirtualHost&gt; 1.3 配置hosts最后在hosts文件里添加域名IP对照， 1127.0.0.1 ymx.com 可能这三个文件会有不同的修改顺序，但是别忘了重启apache，注意在使用的时候ajax里的url参数加上/api，例如：’/api/user/login’ 1.4 原理首先，跨域是浏览器作出的限制，使用ajax才会出现跨域，浏览器从一个域名的网页通过ajax去请求另一个域名下的资源时,域名、端口、协议这是三个有一种方式不同,都会被浏览器认为是跨域，既然跨域是浏览器作出的限制，那么我们可以让浏览器不去跨域，而是直接访问自己的Apache服务器，而Apache可以请求到localhost:3000端口的数据，此时跨域限制得以解决。这种方式，不需要前后端配合。 2.CORS方式(需要前后端配合，官方给的方案)其实最后发现CORS也是可以的，只是我设置的有问题，但是看起来有点麻烦。 后端需要设置响应头信息 1234//第一条设置以后，能解决数据访问问题，但是不能解决跨域问题res.header('Access-Control-Allow-Origin','www.isymx.com');//这个可以解决cookie的限制res.header('Access-Control-Allow-Credentials',true); 前端在发送ajax的时候需要配置xhrFields 12345678910$.ajax(&#123; url:'', type: 'post', xhrFields: &#123; withCredentials: true &#125;, success: function(info)&#123; //... &#125;&#125;);","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"搭建一个基于github和hexo的博客","slug":"hellohexo","date":"2017-01-12T14:00:09.000Z","updated":"2018-09-20T09:41:10.524Z","comments":true,"path":"2017/01/12/hellohexo/","link":"","permalink":"http://yoursite.com/2017/01/12/hellohexo/","excerpt":"这是我的第一篇博客，我只想用它来记录学习路程，之前项目遇见问题，我会查别人的博客，意识到了分享的重要性，于是开始将我的写作放到博客上来。如果有不对的地方，希望大家多多批评指正。","text":"这是我的第一篇博客，我只想用它来记录学习路程，之前项目遇见问题，我会查别人的博客，意识到了分享的重要性，于是开始将我的写作放到博客上来。如果有不对的地方，希望大家多多批评指正。 1.首先你需要安装git和node环境，假如你安装了node，npm是默认安装的。 2.安装hexo你可以先检查一下是否安装了hexo。 1$ hexo -v 如果没有输出版本号，接着安装 1$ npm i hexo -g 3.创建git仓库登陆你的git账号，建立一个仓库，这个仓库名字必须是 用户名.github.io,并且一个github账号只能注册一个博客地址。本文所有的用户名都代表你的github用户名 4.创建本地博客文件夹在你喜欢的任何地方创建一个文件夹，用来创建本地博客，打开终端，cd到这个文件夹，初始化hexo 1$ hexo init 这个过程有可能会报安装依赖失败的error，我在win10上没有遇见，在mac上遇见了，此时安装依赖，即执行 1$ npm install 初始化完成之后，你就可以在本地预览你的博客了，启动服务器，s是server的意思，即执行 1$ hexo s 在本地浏览器地址栏输入http://localhost:4000/可以本地预览你的作品。不过可能看起来似乎有点low。但后期是可以更改主题的。 5.将本地博客推送至远程git仓库找到本地博客文件夹，根目录的_config.yml，拉到最后修改一个配置，注意冒号后有一个空格，每个键名前是两个空格。末尾不要留下空格 1234deploy: type: git branch: master repository: https://github.com/用户名/用户名.github.io.git 开始准备上传 1$ hexo g 上传 1$ hexo d 我在此处出错了，执行下面命令 1$ npm i hexo-deployer-git 下载完依赖之后再次执行 1$ hexo d 上传成功，在浏览器上访问你的用户名.github.io,就可以访问了 6.如何增加博客？在你博客文件夹下运行终端，创建一篇文章 1$ hexo new 文章名字 找到根目录下的source/_posts文件夹，你刚创建的博客md文档就出现了，你就可以在这里编写你的博客了，写好之后你预览了没问题就可以上传 12$ hexo g $ hexo d 7.修改主题如果你不喜欢那种原生的田园风格，可以尝试更换主题，我采用的主题是https://github.com/litten/hexo-theme-yilia,具体配置方案上面有文档，需要注意的是头像的图片地址放在yilia/source下路径，具体你想放在哪里写在yilia/_config.yml配置文件里就行啦！另外这是主题的中文文档地址http://moxfive.coding.me/yelee/ 8.绑定域名 这个要看你想不想绑定了，我是之前就有购买域名，所以用在了这里 1.如果你的域名需要实名认证，请提前认证，大概需要两三天吧。 2.获取github的IP地址：终端 ping 用户名.github.io记录下IP地址，这个IP是要和你的域名绑定的。 3.我是在阿里云购买的域名，登录&gt;控制台&gt;域名&gt;解析&gt;添加记录 CNAME记录值是你的用户名.github.io A对应的记录值是你刚才ping到的IP地址 4.根目录下的&gt;_config.yml修改skip_render: CNAME 5.在你的本地的文件夹根目录&gt;source下创建一个没有后缀的，名为CNAME的文件，里面写上你的域名，注意写错了报404，之后hexo -gand hexo -d 之后大功告成。试试用你的域名访问你的博客吧！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]